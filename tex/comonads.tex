

\pdfoutput=1

\documentclass{amsart}

\usepackage[utf8]{inputenc}

\usepackage[protrusion=true,expansion=true]{microtype}


\usepackage[style=numeric,
 backref=true,
 isbn=false,
 maxnames=3,
 maxbibnames=99 ,                
 uniquename=init ,
]{biblatex}
\bibliography{literature.bib}

\usepackage{ownstyle}


\author{Benedikt Ahrens}
\author{R\'egis Spadotti}

\title[Coinitial semantics for redecoration of triangular matrices]{Coinitial semantics \\ for redecoration of triangular matrices}

\newcommand{\fat}[1]{\textbf{#1}}

\renewcommand{\alpha}{\phi}

\begin{document}


\begin{abstract}
  The heterogeneous codata type of infinite triangular matrices and, in particular, the \emph{redecoration} operation on it, 
  were studied by \citeauthor{DBLP:conf/types/MatthesP11}. In their work,  redecoration is characterized
  as the cobind operation of what the authors call a \enquote{weak constructive comonad}.
  
  In this work, we identify weak constructive comonads as an instance of the more general notion of 
  \emph{relative comonad}.
  Afterwards, building upon the work by \citeauthor{DBLP:conf/types/MatthesP11}, we give a category-theoretic
  characterisation of infinite triangular matrices---equiped with the canonical bisimulation relation and a 
  compatible comonadic $\cobind$ operation---as the \emph{terminal object}
  in some category.
  
  Our results are fully mechanized in the proof assistant \coq.
  \end{abstract}

\maketitle

% \tableofcontents

\section{Introduction}

 Simple inductive types---\textsf{W}-types---are characterized categorically as initial algebras of
 a polynomial functor \parencite{DBLP:journals/apal/MoerdijkP00}.
 Dually, infinite, \emph{coinductive} types are characterized as terminal \emph{co}algebras of suitable functors.
 In the case of coinductive types, the meta-theoretic notion of equality is not adequate. Another notion of sameness for inhabitants of such types, 
 \emph{bisimulation}, was introduced by \textcite{aczel_nonwellfounded}, and also
 a new proof principle called \emph{coinduction}. 
 Modulo this slight complication, it looks like it suffices to dualize the theory of inductive types in order to obtain
 a complete picture of coinductive types.

 
 The characterization of inductive types as initial algebras 
 has been extended to \emph{heterogeneous}---also called \emph{nested}---inductive data types, e.g., the type of $\lambda$-terms,
 in various formulations \parencite{fpt, DBLP:journals/iandc/HirschowitzM10}.
 The main goal of these works is not just to characterize the data type via a universal property, but rather the data type
 \emph{equipped with a well-behaved substitution operation}.
 
 

 In this work we set off to characterize a specific \emph{co}inductive heterogeneous data type---the type family $\Tri$ of 
 infinite triangular matrices as studied by \textcite{DBLP:conf/types/MatthesP11}, equipped with a \emph{co}substitution operation---as a terminal object of some 
 category. For this, we start dualizing the approach by \textcite{DBLP:journals/iandc/HirschowitzM10}, where 
 the crucial notions are the notion of monad and, more importantly, \emph{module over a monad}.
 It turns out that more work than a simple dualization is necessary, for two reasons which we indicate in the following.
 
  
 For a beautiful description and analysis of the codata type of infinite triangular matrices we refer to the article by
 \textcite{DBLP:conf/types/MatthesP11} which is available via open access. The reader is strongly urged to read (the first two sections of) that work 
 before the present one; here we only recall the most important
 definitions:
 the codata type family $\Tri$ of infinite triangular matrices is parametrized by a fixed set for entries not on the diagonal, 
 and indexed by another, \emph{variable}, set for entries on 
 the diagonal. The respective types of its specifying destructors $\head$ and $\tail$ are given in \Cref{fig:tri_destructors}.
 A first difference to the inductive case of the lambda calculus springs to mind:
 while the lambda calculus is essentially a monad---hence an \emph{endo}functor---on sets, the codata type $\Tri$ cannot be considered as such;
 for a given set $A$, the type $\Tri A$, equipped with a suitable \fat{bisimulation} relation, 
 constitutes a \emph{setoid}---a set equipped with an equivalence relation---rather than a set.
 Instead of considering comonads---as the dual notion to monads---we thus have to consider a notion of comonad whose underlying functor is not necessarily endo.
 This is precisely the raison d'\^etre of \emph{relative} comonads (defined below)---the dual notion to the relative monads defined in 
  \parencite{DBLP:conf/fossacs/AltenkirchCU10}. 
 Fortunately, relative comonads have all the nice properties we could ask for; 
 in particular, the notion of module over a monad of \parencite{DBLP:journals/iandc/HirschowitzM10} extends to modules over \emph{relative} monads
 \parencite{ahrens_relmonads}, which can be dualized to obtain comodules over relative comonads.
 
 The other, more important difference between the inductive and the coinductive case stems from \emph{heterogeneity}:
 Two dual operations are responsible for the heterogeneity of the data type of lambda terms and the codata type of infinite triangular
 matrices: while we precompose with taking a \emph{co}product in the case of the abstraction of the lambda calculus---in order to account
 for context extension when passing under a binder---,
 we precompose with taking a \emph{product} when giving the target of the $\tail$ destructor of $\Tri$.
 However, as it turns out, the treatment of the $\tail$ destructor is far more complicated than a dualization of that of the abstraction 
 constructor of the lambda calculus---see \Cref{rem:shift} for a detailed explanation. 
 Describing our approach to a category-theoretic treatment of the $\tail$ destructor is the main purpose of the present work.
 
 All our definitions, examples and lemmas have been implemented in the proof assistant \coq \parencite{coq84pl3}.
 The \coq source files and HTML documentation are available on the project web page \parencite{trimat_coq}.
 In this document, we hence omit the proofs and focus on definitions and statements of lemmas.
 
 
 \subsection*{Some more related work}
 Some related work has been mentioned in the introduction.
 Traditional comonads for functional programming with homogeneous codata types are studied in \parencite{DBLP:conf/sfp/UustaluV01}.
 Redecoration for both finite and infinite triangular matrices is used in \parencite{DBLP:journals/tcs/AbelMU05} to exemplify 
 the expressivity of the studied recursion schemes.
 
 
 
\subsection*{Organisation of the paper}
  In \Cref{sec:preliminaries} we introduce some concepts and notations used later on.
  In \Cref{sec:comonads} we define the category of comonads relative to a fixed functor.
  In \Cref{sec:comodules} we define comodules over relative comonads and give some constructions of comodules.
  In \Cref{sec:coalgebras_for_tri} we explain an important difference between the lambda calculus and infinite triangular matrices
    as heterogeneous data types. We then set up the necessary definitions to state our main theorem (\Cref{ex:final_sem_tri}), 
    characterizing the codata type $\Tri$ as terminal object in some category.
  In \Cref{sec:formal} we explain some details of the formalization of this work in the proof assistant \coq.
  A table with the correspondence between formal and informal definitions is given in \Cref{sec:table_formal_informal}.
\section{Preliminaries}\label{sec:preliminaries}

In this paper we work in a type-theoretic foundational system and thus use type-theoretic notation,  writing $t:T$ to indicate that $t$ is of type $T$. 
Whenever an operation takes several arguments, we write some of them as indices; these indices might be omitted when 
they can be deduced from the type of the later arguments.
We assume basic knowledge of category theory; any instances used are defined in the following.

\begin{definition}[Some categories]\label{def:set_setoid}
 We denote by $\Set$ the category of sets and total functions. 
 
 We denote by $\Setoid$ the category an object of which is a set equipped with an equivalence relation.
 A morphism between setoids is a set-theoretic function between the underlying sets that is compatible with the equivalence relations of the source and target setoids.
 Given a setoid $T$, we write $t\sim t'$ for related elements $t$ and $t'$ in $T$.
\end{definition}



\begin{definition}\label{def:eq}
 The functor $\eq : \Set\to\Setoid$ is defined as the left adjoint to the forgetful functor 
  $U : \Setoid \to \Set$.
  Explicitly, the functor $\eq$ sends any set $X$ to the setoid $(X,=_X)$ given by the set $X$ itself, equipped
  with the equality relation $=_X$ on $X$.
\end{definition}


\begin{remark}[Notation for product]
  We denote the category-theoretic binary product of objects $A$ and $B$ of a category $\C$ by $A\times B$.
  We write $\pr_1(A,B) : \C(A\times B, A)$ and $\pr_2(A,B) :\C(A\times B, B)$ for the projections, and we omit the 
  argument $(A,B)$ when it is clear from the context.
  Given $f : \C(A, B)$ and $g : \C(A,C)$, we write $\langle f,g\rangle : \C(A,B\times C)$ for the induced map into the product such that
  $\comp{\langle f,g\rangle}{\pr_1} = f$ and $\comp{\langle f,g\rangle}{\pr_2} = g$.
\end{remark}

Both of the categories of \Cref{def:set_setoid} have binary products; they are \emph{cartesian monoidal}, i.e.\ the terminal 
object is neutral with respect to the multiplication. Functors preserving the monoidal structure \textbf{up to isomorphism}
are called \emph{strong monoidal}:

\begin{definition}[Strong monoidal functor]\label{def:monoidal_functor}
 A functor $F:\C\to\D$ between cartesian monoidal categories is \fat{strong monoidal} if, for any two objects $A$ and $B$ of $\C$,
  the morphism
 \[ \alpha^F_{A,B} := \bigl\langle F(\pr_1), F(\pr_2) \bigr\rangle : \D\bigl(F(A\times B), FA\times FB\bigr)\enspace  \] 
 is an isomorphism.
 (Note that for \emph{cartesian} monoidal categories, the family $\alpha$ of morphisms automatically 
  is compatible with the unitators and associators of the source and target categories, 
  since it is given by a universal property. 
  We shall not need strong monoidal functors between arbitrary monoidal categories.)
\end{definition}

\begin{example}
  The functor $\eq: \Set \to \Setoid$ of \Cref{def:eq} is strong monoidal.
\end{example}


\section{Relative comonads and their morphisms}\label{sec:comonads}

\emph{Relative monads} were defined by \textcite{DBLP:conf/fossacs/AltenkirchCU10} as a notion of monad-like structure
whose underlying functor is not necessarily an endofunctor.
The dual notion is that of a relative \emph{co}monad:

\begin{definition}[Relative comonad]\label{def:rel_comonad}
  Let $F:\C\to\D$ be a functor. A \fat{relative comonad $T$ over $F$} is given by
  \begin{packitem}
   \item a map $T:\C_0 \to \D_0$ on the objects of the categories involved;
   \item an operation $\counit : \forall A : \C_0, \D(TA,FA)$;
   \item an operation $\cobind: \forall A,B:\C_0, \D(TA,FB) \to \D(TA,TB)$
  \end{packitem}
  such that 
  \begin{packitem}
   \item $\forall A,B:\C_0, \forall f:\D(TA,FB), \comp{\cobind(f)}{\counit_B} = f$;
   \item $\forall A : \C_0, \cobind(\counit_A) = \id_{TA}$;
   \item $\forall A,B,C:\C_0, \forall f : \D(TA,FB),\forall g:\D(TB,FC), \\
        \comp{\cobind(f)}{\cobind(g)} = \cobind(\comp{\cobind(f)}{g})$.
  \end{packitem} 
\end{definition}
Just like relative monads, relative comonads are functorial:
\begin{definition}[Functoriality for relative comonads]\label{def:lift}
 Let $T$ be a  comonad relative to $F:\C\to\D$.
 For $f : \C(A,B)$ we define
  \[ \lift^T(f) := \cobind(\comp{\counit_A}{Ff}) \enspace .  \]
 The functor properties are easily checked.
\end{definition}
Relative comonads over the identity functor are exactly comonads.
A nontrivial instance of relative comonads is given by the coinductive data type of infinite triangular matrices
studied by \textcite{DBLP:conf/types/MatthesP11}. We suggest the reader consults the first two sections of their work
in order to understand this example.


\begin{example}[\textcite{DBLP:conf/types/MatthesP11}]\label{ex:tri_comonad}
Let $E$ be an arbitrary fixed set.
   Infinite triangular matrices over the (variable) type $A$ are given by the destructors shown in \Cref{fig:tri_destructors},
    equiped with a coinductively defined equivalence relation, a \emph{bisimulation}.
    We write $t \sim t'$ for related matrices $t$ and $t'$.

\begin{figure}[hbt]
  \begin{center}

     \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t : \Tri(A)$}\doubleLine
     \UnaryInfC{$\head_A(t) : A$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t : \Tri(A)$}\doubleLine
                                       \UnaryInfC{$\tail_A(t) : \Tri(E\times A)$}
                                       \DisplayProof%

  \end{center}
\vspace{2ex}
  \begin{center}
                                            \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t \sim t'$}\doubleLine
     \UnaryInfC{$\head(t) = \head(t')$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t \sim t'$}\doubleLine
                                       \UnaryInfC{$ \tail(t) \sim \tail(t')$}
                                       \DisplayProof   
  \end{center}
  \caption{Destructors and bisimulation for the coinductive family $\Tri$} \label{fig:tri_destructors}
\end{figure}

\noindent
\textcite{DBLP:conf/types/MatthesP11} define a notion of \emph{weak constructive comonad}, and show that the data type $\Tri$
  is an instance of such a comonad. 
  Such a weak constructive comonad, however, is \emph{precisely}
  a comonad relative to the functor $\eq : \Set\to\Setoid$.
  The $\counit$ is given by the operation $\head$.
  The $\cobind$ operation---called \emph{redecoration} or $\redec$ in \parencite{DBLP:conf/types/MatthesP11}--- of type
   \[ \redec_{A,B} : \Setoid(\Tri A,\eq B) \to \Setoid(\Tri A,\Tri B )\] is defined 
  corecursively, for $f:\Setoid(\Tri A,\eq B)$  and $t : \Tri A$ by
      \begin{align}\head\bigl(\redec~f~t\bigr) &:= f~t \quad\text{ and } \notag\\
                     \tail\bigl(\redec~f~t\bigr) &:= \redec\bigl(\extend~f\bigr)(\tail~t) \enspace . \label{eq:rest_redec}
      \end{align}
Here, the family of functions 
     \[\extend_{A,B} : \Setoid(\Tri A,\eq B) \to \Setoid\bigr(\Tri (E \times A),\eq(E\times B)\bigr)\]
  is suitably defined to account for the change of the type of the argument of $\redec$ when redecorating $\tail~t : \Tri(E\times A)$
  rather than $t : \Tri A$, namely
  \[ \extend(f) := \langle \comp{\head_{E\times A}}{\pr_1(E,A)} , \comp{\cut_A}{f} \rangle \enspace . \]
  The auxiliary function $\cut_A : \Tri(E\times A) \to \Tri A$ is defined corecursively via
   \begin{align*}\head\bigl(\cut~t\bigr) &:= \pr_2(\head~t) \quad\text{ and } \\
                     \tail\bigl(\cut~t\bigr) &:= \cut(\tail~t) \enspace . 
      \end{align*}
 Note that what is called $\extend$ here is called \textit{lift} in \parencite{DBLP:conf/types/MatthesP11}.
\end{example}

\begin{remark}
In the definition of the $\extend$ operation in \Cref{ex:tri_comonad} the auxiliary operation $\cut$ plays a central r\^ole.
It should be remarked here that, using functoriality of $\Tri$, one can define another operation of the same type, namely the family of 
maps $\Tri(\pr_2(E,A)) : \Tri(E\times A) \to \Tri A$ for
all sets $A$. Had we used this operation rather than the corecursively defined $\cut$ of \Cref{ex:tri_comonad}, 
then the third comonad law would have failed; we refer to \parencite{DBLP:conf/types/MatthesS07} for details.
\end{remark}

The notion of relative comonad captures many properties of $\Tri$ and its redecoration operation, in particular the interplay
of redecoration with the destructor $\head$ via the first two comonad laws.
Much of the rest of the present work is concerned with finding a suitable categorical notion that captures the interplay 
of redecoration with the other destructor, $\tail$. Once we have found such a categorical notion, we can use 
it to give a definition of what a \enquote{coalgebra} for the signature of infinite triangular matrices is, 
where the codata type $\Tri$ is supposed to constitute the terminal object.

A first attempt might be to characterize $\tail$ as a \emph{morphism of comonads}:


\begin{definition}[Morphism of relative comonads]\label{def:comonad_morphism}
 Let $T$ and $S$ be comonads relative to a functor $F : \C \to \D$. A \fat{morphism of relative comonads} $\tau : T \to S$
  is given by a family of morphisms \[\tau_A : \D(TA,SA)\] such that for any $A : \C_0$,
     \[  \counit^T_A = \comp{\tau_A}{\counit^S_A} \]
   and for any $A,B : \C_0$ and $f : \D(SA,FB)$,
   \[  \comp{\cobind^T(\comp{\tau_A}{f})}{\tau_B} = \comp{\tau_A}{\cobind^S(f)} \enspace .  \]
\end{definition}

Relative comonads over a fixed functor $F$ and their morphisms form a category $\RComonad(F)$.

\begin{remark}
A morphism $\tau : T\to S$ of relative comonads over a functor $F:\C\to\D$ is  \emph{natural}
with respect to the functorial action of \Cref{def:lift}.
\end{remark}




At first glance, one might hope for $\tail$ to constitute the carrier of a morphism of relative comonads, i.e.\ one might 
guess that the axioms of comonad morphism capture the interplay of redecoration with the destructors $\head$ and $\tail$.
Indeed, it is possible to equip the target $\Tri(E\times \_)$ of $\tail$ with the structure of comonad---we show one such
possibility in \Cref{product_comonad}. However, we have \emph{not} found any way to endow $\Tri$ and $\Tri(E\times \_)$ with a comonad structure in a way
that turns $\tail$ into a morphism of comonads.


\begin{definition}\label{product_comonad}
  Let $T$ be a comonad relative to a strong monoidal functor $F:\C\to\D$ between cartesian monoidal categories,
  and let $E:\C_0$ be a fixed object of $\C$.
 The map $A\mapsto T(E\times A)$ inherits the structure of a comonad relative to $F$ from $T$: the 
 counit is defined as
   \[ \counit_A := \comp{\counit^T_{E\times A}}{F\pr_2(E,A)} \]
  and the cobind operation as
   \begin{align*} 
            \cobind_{A,B} : \D\bigl(T(E\times A),FB\bigr) &\to \D\bigl(T(E\times A),T(E\times B)\bigr) \\
              f &\mapsto  \cobind^T(\extend'~f)
   \end{align*}
  with $\extend'$ defined as 
  \begin{align*} \extend' : \D\bigl(T(E\times A),FB\bigr) &\to \D\bigl(T(E\times A), F(E\times B)\bigr) \enspace , \\ 
                                            f & \mapsto \comp{\langle \comp{T(\pr_1)}{\counit^T_E}, f \rangle}{{\alpha^{F}_{E,B}}^{-1}} \enspace .
  \end{align*}
\end{definition}
 Using such a comonad as the target comonad for $\tail$, one might now 
 try to characterize the destructor $\tail$ of the triangular matrices of \Cref{ex:tri_comonad}
 as a morphism of relative comonads.
 However, this fails already for the law involving $\counit$: we would have to prove $\head = \comp{\tail}{\comp{\head}{\pr_2}}$,
 which fails each time the first two entries on the diagonal are not equal.
 We leave it to the reader to find counterexamples for the comonad law involving $\cobind$.

For heterogeneous inductive types, \textcite{DBLP:journals/iandc/HirschowitzM10} solve an analogous question by considering the notion of
\emph{module over a monad}. We  dualize their approach by introducing comodules over (relative) comonads.



\section{Comodules over relative comonads}\label{sec:comodules}

In this section we dualize the notion of module over a relative monad as developed in \parencite{ahrens_relmonads}.
This dualization is straightforward.


\begin{definition}[Comodule over relative comonad]\label{def:comodule}
 Let $T$ be a relative comonad over the functor $F:\C\to\D$, and let $\E$ be a category.
 A \fat{comodule over T towards $\E$} consists of
   \begin{packitem}
   \item a map $:\C_0 \to \E_0$ on the objects of the categories involved;
   \item an operation $\mcobind: \forall A,B:\C_0, \D(TA,FB) \to \E(MA,MB)$
  \end{packitem}
  such that 
  \begin{packitem}
   \item $\forall A : \C_0, \mcobind(\counit_A) = \id_A$;
   \item $\forall A,B,C:\C_0, \forall f : \D(TA,FB),\forall g:\D(TB,FC), \\
        \comp{\mcobind(f)}{\mcobind(g)} = \mcobind(\comp{\cobind(f)}{g})$ .
  \end{packitem}

\end{definition}

Every relative comonad comes with a canonical comodule over it, the \emph{tautological comodule}:

\begin{definition}[Tautological comodule]\label{def:tautological_comodule}
  Given a comonad $T$ relative to $F:\C\to\D$, the assignment $A \mapsto TA$ yields a comodule over $T$ 
  with target category $\D$, the \textbf{tautological comodule} of $T$, also called $T$.
  The comodule operation is given by
    \[  \mcobind^T(f) := \cobind^T(f) \enspace . \]
\end{definition}


A \emph{morphism of comodules} is given by a family of morphisms that is compatible with 
the comodule operation:

\begin{definition}[Morphism of comodules]\label{def:morphism_of_comodules}
 Let $M, N : \C \to \E$ be comodules over the comonad $T$ relative to  $F:\C \to \D$.
 A \fat{morphism of comodules} from $M$ to $N$ is given by a family of morphisms 
   \[ \alpha_A:\E(MA,NA) \]
 such that for any $A,B:\C_0$ and $f : \D(TA,FB)$ one has
 \[   \comp{\mcobind^M(f)}{\alpha_B} = \comp{\alpha_A}{\mcobind^N(f)} \enspace . \]
\end{definition}


Composition and identity of comodule morphisms happens pointwise. We thus obtain a category of comodules
over a fixed comonad, towards a fixed target category:

\begin{remark}[Category of comodules]
 Fix a comonad $T$ relative to $F:\C\to\D$ and a category $\E$.
 Comodules over $T$ towards $\E$ and their morphisms  form a category $\RComod(T,\E)$.
\end{remark}

Similarly to relative comonads, comodules over these are functorial:

\begin{definition}[Functoriality for comodules]\label{def:comodule_lift}
 Let $M : \RComod(T,\E)$ be a comodule over $T$ towards some category $\E$. For $f : \C(A,B)$ we define
  \[ \mlift^S(f) := \mcobind(\comp{\counit_A}{Ff}) .  \]
\end{definition}


\begin{remark}
  The family of morphisms constituting a comodule morphism is actually natural with respect to the functoriality 
  defined in \Cref{def:comodule_lift}.
\end{remark}

Given a morphism of comonads, we can \enquote{transport} comodules over the source comonad to comodules over the target comonad:


\begin{definition}[Pushforward comodule]\label{def:pushforward_comodule} % checked
  Let $\tau : T\to S$ be a morphism of comonads relative to a functor $F : \C \to \D$, and let furthermore $M$ be a 
  comodule over $T$ towards a category $\E$. We define the \fat{pushforward comodule} $\tau_*M$ to be the comodule over $S$ given by
  \[  \tau_*M(A) := MA \]
  and, for $f : \D(SA,FB)$,
   \[ \mcobind^{\tau_*M}(f) := \mcobind^M(\comp{\tau_A}{f}) \enspace . \]
   
  \noindent
  Pushforward is functorial: if $M$ and $N$ are comodules over $T$ with codomain category $\E$, and $\alpha : M\to N$ is 
    a morphism of comodules, then we define \[\tau_*\alpha : \tau_*M \to \tau_*N\] 
    as the family of morphisms
     \[ (\tau_*\alpha)_A := \alpha_A \enspace . \]
  It is easy to check that this is a morphism of comodules (over $S$) between $\tau_*M$ and $\tau_*N$.
  Pushforward thus yields a functor $\tau_*:\RComod(T,\E) \to \RComod(S,\E)$.
\end{definition}


\begin{definition}[Morphism of comonads induces morphism of comodules]\label{def:induced} % checked
  Let $\tau : T\to S$ be a morphism of comonads relative to a functor $F : \C \to \D$.
  Then $\tau$ gives rise to a morphism of comodules over $S$ from the pushforward of the tautological comodule
  of $T$ along $\tau$ to the tautological comodule over $S$,
  \[ \induced{\tau} : \tau_*T \to S \enspace , \quad \induced{\tau}_A := \tau_A \enspace . \]
\end{definition}




\section{Coalgebras for infinite triangular matrices}\label{sec:coalgebras_for_tri}


Our goal is to define \fat{coalgebras} for the signature of infinite triangular matrices such that 
the codata type $\Tri$ defined in \Cref{ex:tri_comonad} constitutes the \fat{terminal such coalgebra}.
Since $\Tri$ forms a comonad relative to the functor $\eq:\Set\to\Setoid$, it seems reasonable to define
an arbitrary coalgebra as such a relative comonad as well, equiped with some extra structure which remains to be defined.
A morphism of coalgebras would then be defined as a morphism of relative comonads that is compatible with that extra structure.

The purpose of this extra structure is to characterize the destructor $\tail$, that is, its \emph{type} as well as
its \emph{behaviour with respect to the redecoration operation}.
Dualizing the approach of \textcite{DBLP:journals/iandc/HirschowitzM10}, we hope to characterize $\tail$ as a morphism of 
comodules of specified type, which would allow us to define the extra structure of an arbitrary coalgebra
as a suitable comodule morphism as well.

In order to turn $\tail$ into a morphism of comodules, the crucial task is to suitably endow the source and target functors
$\Tri$ and $\Tri(E\times \_)$, respectively, with a comodule structure over the comonad $\Tri$.
For this, we now take a closer look at how the $\extend$ operation for $\Tri$ is defined. Its purpose is to 
modify the function $f$ used for redecoration, when redecorating $\tail~t : \Tri(E\times A)$ rather than $t : \Tri A$.
First we note an important difference between the $\extend$ operation and its analogue in the inductive case:

\begin{remark}[$\shift$ operation for the lambda calculus]\label{rem:shift}
  The heterogeneous data type of lambda terms comes with a term constructor $\abs_A : \ULC(A^*) \to \ULC A$, which 
  is the constructor responsible for the heterogeneity of that data type.
  We compare the $\extend$ operation to the one with analogue purpose in the case of the lambda calculus,
  the $\shift$ operation, of type
  \begin{equation}  \shift_{A,B} : \Set(A,\ULC B) \to \Set\bigl(A^*,\ULC(B^*)\bigr) \enspace .\label{eq:shift}\end{equation}
  Here $\ULC A$ denotes the set of lambda terms in context $A$, and $A^*:=1 + A$ denotes the context $A$ extended by a distinguished 
  variable---the variable bound by the abstraction constructor.
  
  The $\shift$ operation is used in the definition of the monadic substitution operation
  \[ \subst_{A,B} : \Set(A,\ULC B) \to \Set(\ULC A,\ULC B) \]
  of the lambda calculus, when recursively substituting under an abstraction:
   \[ \subst~f~(\abs~t):= \abs\bigl(\subst~(\shift~f)~t\bigr) \enspace . \]
  The reader is encouraged to compare this equation to \Cref{eq:rest_redec}.
  
  The $\shift$ operation can be defined in monadic terms, for any monad $T$ on the category of sets such that,
  when $T$ is instantiated by the monad $\ULC$, it becomes the specific $\shift$ operation of \Cref{eq:shift}.
  
  However, we were \emph{not} able to express the $\extend$ operation of $\Tri$ entirely in terms of categorical and comonadic operations. Indeed, if
  one dualizes the categorical definition of $\shift$, one obtains an operation that has the same type as $\extend$, 
  but for which, when used to define the redecoration, some comonadic property of redecoration fails.
  More specifically, it is the auxiliary $\cut$ operation as defined in \Cref{ex:tri_comonad} which does not seem to be 
  definable in categorical terms. There is an operation of the same type which is categorical---see \Cref{canonical_cut}---but
  which, when used for the definition of the $\extend$ operation, yields a \enquote{redecoration} operation for which the third comonad law fails.
  Details are given in an article by \textcite{DBLP:conf/types/MatthesS07}.
\end{remark}


The failure to describe the $\extend$ operation---more precisely, the auxiliary $\cut$---in categorical terms leads us 
to considering comonads that come with a specified $\cut$ operation for some fixed object $E$ in the source category:




\begin{definition}[Relative comonad with cut]\label{def:rel_comonad_with_cut}
 Let $\C$ and $\D$ be categories with binary products and $F:\C\to\D$ a strong monoidal functor. Let $E:\C_0$ be a fixed object of $\C$.
 We define a \fat{comonad relative to $F$ with cut relative to $E$} to be a comonad $T$ relative to $F$ together with a $\cut$ operation 
    \[ \cut : \forall~A:\C_0, T(E\times A) \to TA \]
 satisfying the following axioms:
  \begin{itemize}
   \item $\forall~A:C_0, \comp{\cut_A}{\counit_A} = \comp{\counit_{E\times A}}{F(\pr_2(E,A))}$;
   \item $\forall~A~B:C_0,\forall~f:\D(TA,FB), \comp{\cut_A}{\cobind(f)} = \comp{\cobind(\extend~f)}{\cut_B}$,
  \end{itemize}

  \noindent
  where, for $f:\D(TA,FB)$, we define $\extend(f) : \D\bigl(T(E\times A),F(E\times B)\bigr)$ as
       \[ \extend(f) := \comp{\comp{\langle T(\pr_1) , \cut \rangle}{(\counit_E\times f)}}{{\alpha^{F}_{E,B}}^{-1}} \enspace . \]
  
\end{definition}

Morphisms of comonads with cut are morphisms of comonads that are compatible with the respective $\cut$ operations:

\begin{definition}[Morphism of comonads with cut]\label{def:morphism_comonad_cut}
 Let $(T,\cut^T)$ and $(S,\cut^S)$ be two comonads relative to a functor $F$ with cut relative to $E$ as in \Cref{def:rel_comonad_with_cut}.
 A \emph{morphism of comonads with cut} is a comonad morphism $\tau$ between the underlying comonads as in \Cref{def:comonad_morphism} that 
 commutes suitably with the respective $\cut$ operations, i.e.\ for any $A : \C_0$,
  \[ \comp{\tau_{E \times A}}{\cut^S_A}  = \comp{\cut^T_A}{\tau_A} \enspace . \]
\end{definition}


Comonads with cut relative to a fixed functor $F:\C\to\D$ and $E:\C_0$ form a category $\RComonadWC(F,E)$.
There is the obvious forgetful functor from $\RComonadWC(F,E)$ to $\RComonad(F)$.
Conversely, any comonad $T$ relative to a suitable functor can be equiped with a $\cut$ operation, using functoriality of $T$:



\begin{remark}[Canonical $\cut$ operation]\label{canonical_cut}
 Any comonad $T$ relative to a functor $F$ as in \Cref{def:rel_comonad_with_cut} can be equiped with a $\cut$ operation by setting
   \[ \cut_A := \lift^T\bigl(\pr_2(E,A)\bigr) \enspace . \]
 It follows from the axioms of comonad morphism that a comonad morphism $\tau : T\to S$ satisfies the equation of \Cref{def:morphism_comonad_cut} 
 for the thus defined operations $\cut^T$ and $\cut^S$, hence constitutes a morphism of comonads with cut from $(T,\cut^T)$ to $(S,\cut^S)$.
\end{remark}

The functor given by the canonical $\cut$ operation, followed by the forgetful functor, yields the identity. We can thus view
relative comonads with cut as a generalization of relative comonads.


Our prime example of relative comonad comes with a $\cut$ operation that is not the canonical one:

\begin{example}[$\cut$ for $\Tri$]\label{def:cut_for_tri}
  The relative comonad $\Tri$ from \Cref{ex:tri_comonad}, together with the $\cut$ operation defined there, 
  is a comonad with cut as in \Cref{def:rel_comonad_with_cut}.
\end{example}





Given a comodule $M$ over a relative comonad with cut, we define a comodule over the same comonad obtained by precomposition of $M$ with
\enquote{product with a fixed object $E$}:


\begin{definition}[Precomposition with product]\label{def:product_in_context}
 Suppose $F:\C\to\D$ is a strong monoidal functor, and $T$ is a comonad relative to $F$ with a $\cut$ operation 
 relative to $E:\C_0$ as in \Cref{def:rel_comonad_with_cut}.
 Given a comodule $M$ over $T$,  precomposition with \enquote{product with $E$}
 gives a comodule $M(E\times\_)$ over $T$,
  \[    M(E\times \_) : A \mapsto M(E\times A) \enspace . \]
 The comodule operation is deduced from that of $M$ by 
 \begin{align*} \mcobind^{M(E\times\_)}_{A,B} : \D(TA,FB)&\to \E\bigl(M(E\times A), M(E\times B)\bigr) \enspace ,\\
                                                      f &\mapsto \mcobind^M_{E\times A,E\times B}(\extend(f)) \enspace ,
  \end{align*}                                        
where the $\extend$ operation is the one defined in \Cref{def:rel_comonad_with_cut}.
 
 Furthermore, given two comodules $M$ and $N$ over $\T$ with target category $\E$, and a comodule morphism $\alpha : M \to N$, then 
 we can define a comodule morphism \[\alpha(E\times \_) : M(E\times \_) \to N(E\times \_) \] by setting
          \[ \alpha(E \times \_)_A := \alpha_{E\times A} \enspace . \]
  
  \noindent
  We thus obtain an endofunctor on the category of comodules over $T$ towards $\E$,
   \[ M \mapsto  M (E\times \_) : \RComod(T,\E) \to \RComod(T,\E) \enspace . \]
\end{definition}


Before we give an example---really, the reason we did all this work---using such a comodule, we state some more facts about 
the construction just described:

\begin{remark}[Pushforward commutes with product in context]\label{rem:prod_pullback_commute}
 Note that the constructions of \Cref{def:product_in_context} and \Cref{def:pushforward_comodule} commute in the sense that
 we have an isomorphism of comodules \[\tau_*(M(E\times \_)) \cong (\tau_*M)(E \times \_)  \]
 given pointwise by identity morphisms.
\end{remark}



It directly follows from the definition that the cut operation of any comonad $T$ with cut 
constitutes a comodule morphism $\cut : T(E\times \_) \to T$.
We can thus restate the definiton of a morphism of comonads with cut as in \Cref{def:morphism_comonad_cut} by asking the following diagram 
of comodule morphisms (in the category $\RComod(S,\D)$) to commute
(where in the upper left corner we silently add an isomorphism as in \Cref{rem:prod_pullback_commute}):
 \[ \begin{xy}
       \xymatrix{  **[l] \tau_*T(E\times \_ )  \ar[r]^{\tau_*(\cut^T)} \ar[d]_{\induced{\tau}(E\times \_)}  &  **[r] \tau_*T \ar[d]^{\induced{\tau}} \\
                   **[l]  S (E\times \_ ) \ar[r]_{\cut^S}  &  **[r] S  \enspace .
        }
      \end{xy}
   \]


The construction of \Cref{def:product_in_context} yields a categorical characterization of the $\tail$ deconstructor---%
more precisely, of \Cref{eq:rest_redec}, via the notion of comodule morphism:


\begin{example}[$\tail$ is a comodule morphism]\label{ex:tail_comodule}
 Consider the comonad $\Tri$, equiped with the $\cut$ operation of \Cref{def:cut_for_tri}.
 The destructor \constfont{\tail} of \Cref{ex:tri_comonad} is a morphism of comodules over the comonad $\Tri$ 
  from the tautological comodule  $\Tri$ to $\Tri(E\times \_)$.
\end{example}








We now define a category in which the codata type of triangular matrices, equiped with the bisimulation relation of \Cref{ex:tri_comonad}
and the comonadic redecoration, constitutes the terminal object. We call an object of this category a \emph{coalgebra of triangular matrices}, 
even though we do not define the category as a category of coalgebras of a given endofunctor.

The definition of such a coalgebra is obtained by collecting all the information we have gathered so
far about the comonad $\Tri$, and abstracting from this particular comonad:


\begin{definition}[Coalgebras of infinite triangualar matrices]\label{def:cat_tri}
   Let $E:\Set_0$ be a set.
   Let $\mathcal{T} = \mathcal{T}_E$ be the category where an object consists of
   \begin{itemize}
    \item a comonad $T$ over the functor $\eq:\Set\to\Setoid$ with $\cut$ relative to $E$ and
    \item a morphism $\tail$ of comodules over $T$ of type $T \to T(E\times \_)$
   \end{itemize}
   such that for any set $A$,
    \[ \comp{\cut_A}{\tail_A} = \comp{\tail_{E\times A}}{\cut_{E\times A}} \enspace . \]
   The last equation can be stated as an equality of comodule morphisms as
     \[ \comp{\cut}{\tail} = \comp{\tail(E\times \_)}{\cut(E\times\_)} \quad \bigl( = (\comp{\tail}{\cut})(E\times \_)\bigr)\enspace . \]

  
   
   A morphism between two such objects $(T,\tail^T)$ and $(S,\tail^S)$
   is given by a morphism of relative comonads with cut $\tau : T \to S$ such that
   the following diagram of comodule morphisms in the category $\RComod(S,\E)$ commutes,
   
   \[ \begin{xy}
       \xymatrix{   \tau_*T  \ar[r]^{\tau_*(\tail^T)} \ar[d]_{\induced{\tau}}  &  **[r] \tau_*T (E\times \_ )\ar[d]^{\induced{\tau}(E\times \_)} \\
                    S  \ar[r]_{\tail^S}  &  **[r] S (E\times \_ ) \enspace .
        }
      \end{xy}
   \]

   \noindent
   Here in the upper right corner we silently insert an isomorphism as in \Cref{rem:prod_pullback_commute}.
\end{definition}   
   
We now have all the ingredients to state (and prove) our main theorem:
\begin{theorem}[Coinitial semantics for triangular matrices with redecoration]\label{ex:final_sem_tri} % checked   
   The pair $(\Tri, \tail)$ consisting of the relative comonad with cut $\Tri$ of \Cref{def:cut_for_tri} together with 
    the morphism of comodules $\tail$ of \Cref{ex:tail_comodule},
   constitutes the terminal---\enquote{coinitial}---coalgebra of triangular matrices.
\end{theorem}

\begin{proof}[Proof sketch]
   For a given coalgebra $(T,\tail^T)$, the (terminal) morphism $\bigcirc = \bigcirc_T:T\to\Tri$ is defined via the corecursive equations
    \begin{align}\head\bigl(\bigcirc~t\bigr) &:= \counit^T~t \quad\text{ and } \label{eq:terminal_top}\\
                     \tail\bigl(\bigcirc~t\bigr) &:= \bigcirc(\tail^T~t) \enspace . \label{eq:terminal_rest}
      \end{align}
      By coinduction we show that the map $\bigcirc$ is compatible with $\cobind$ and $\cut$ operations of the source and 
   target coalgebras. We omit these calculations, which can be consulted in the \coq source files.
   
   Note that there is actually no choice in this definition: \Cref{eq:terminal_top} is forced upon us since we want $\bigcirc$ to constitute 
   a morphism of comonads---the equation directly corresponds to one of the axioms.
   \Cref{eq:terminal_rest} is forced upon us by the diagram a morphism of coalgebras has to make commute.
   
   The same argument is used to show, again by coinduction, that any two morphisms of coalgebras $\tau,\rho : (T,\tail^T) \to (\Tri,\tail)$
   are equal (i.e.\ extensionally bisimilar), thus concluding the proof.
   
   
\end{proof}




\section{Formalization in \coq}\label{sec:formal}

All our definitions and theorems are mechanized in the proof assistant \coq \parencite{coq84pl3}.
The formalization of infinite triangular matrices is taken from the work by \textcite{DBLP:conf/types/MatthesP11},
and only slightly adapted to compile with the version of \coq we use.
The mechanization does \emph{not} rely on any additional axioms.
The \coq source files and HTML documentation are available from the project web site \parencite{trimat_coq}.

In the following we explain some of our design choices for this mechanization
and point out differences between the pen-and-paper definitions and the mechanized ones.



\subsection{Implementation choices}

We explain two choices we made in the course of the formalization in \coq. The first choice concerns
the formalization of categories, more precisely, how to formalize \emph{equality of morphisms}.
The second choice concerns the formalization of algebraic structures.

\subsubsection{Setoids for hom-sets}
We formalize categories to be given by a type of objects and a dependent type---indexed by pairs of objects---of morphisms,
equiped with suitable composition and identity operations satisfying appropriate axioms.
More precisely, the family of morphisms is given by a family of \emph{setoids}, where the setoidal equivalence relation on each
type of morphisms denotes the equality relation on these morphisms. This approach was first used by
\textcite{aczel_galois} in the proof assistant \texttt{LEGO}, and also by \textcite{concat}  in their library
of category theory in \coq.
Alternatively, we could have chosen to consider morphisms modulo propositional equality.

Indeed, the morphisms we consider---morphisms of comonads and comodules---are given by structures
bundling a lot of data and properties; in order to consider two such morphisms as equal, we usually only compare one field of the 
corresponding records. Furthermore, this field usually consists of a (dependent) function.
It would be rather cumbersome to reduce equality of two such records to extensional equality of one of their fields, 
necessitating the use of the axioms of propositional and functional extensionality.
Using setoids for morphisms instead seems to come with less overhead and conceptually cleaner.



\subsubsection{Records vs.\ classes}
Two approaches to the formalization of mathematical structures have been used extensively in \coq: on the one hand, packaging structures
in \emph{record types}  in combination with use of \emph{canonical structures}, is used with success, e.g., in 
the formalisation of algebraic structure in the context of the proof of the Feit-Thompson theorem \parencite{DBLP:conf/tphol/GarillotGMR09}.
On the other hand, \textcite{DBLP:journals/mscs/SpittersW11} suggest the use of \emph{type classes}, in particular when multiple inheritance
is an issue.

In the present formalization, we decide to use records rather than classes, since the strongest argument for type classes---multiple inheritance---does 
not occur.
We make use of canonical structures in order for \coq to deduce instance of categories when we mention objects of a category; 
in particular, this is used to allow for overloading of the notation for morphisms of a category.
We can thus conveniently use the same arrow symbol to denote the type of morphisms between two comonads, between two comodules and so on.


\subsection{Formal vs.\ informal definitions}

The only noteworthy discrepancy between formal and informal definition arises in the definition of the codata type of infinite 
triangular matrices:
in \coq, coinductive types are specified through \fat{constructors} rather than \fat{destructors}.
However, one can easily define inverse functions and work in terms of destructors afterwards.
Work on the the declaration of coinductive types via destructors is done in \agda, cf.\ \parencite{DBLP:conf/popl/AbelPTS13}.
Other than that, the informal definitions correspond closely to the formalized ones---which might also stem from the fact that 
the formalization was used as a research tool, playing an essential r\^ole in the development of this work.

\section{Conclusions and future work}



We have given a category-theoretic characterisation, via a universal property, of infinite triangular matrices
equiped with a comonadic redecoration operation.

While a significant part of our work---surmounting the non-categoricity of the $\cut$ operation---seems to be specific to this particular codata type,
we believe that our work proves the suitability of the notion of relative (co)monads and (co)modules thereover for 
a categorical treatment of coinductive data types.


We plan to pursue two obvious lines of work:
Firstly, we will work on a suitable notion of \emph{signature} for the specification of coinductive data types.
Secondly, we hope to integrate \emph{equations} into the notion of signature, equations which 
will allow, e.g, considering branching trees modulo permutation of subtrees.
 

\subsection*{Acknowledgments}
 We thank Ralph Matthes and Paige North for many helpful discussions, and Andr\'e Hirschowitz for providing feedback on
 a draft of this paper.

\printbibliography


\appendix

\input{formal_table}

\end{document}



















