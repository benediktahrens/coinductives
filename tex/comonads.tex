

\pdfoutput=1

\documentclass{amsart}

\usepackage[protrusion=true,expansion=true]{microtype}


\usepackage[style=numeric,
 backref=true,
 isbn=false,
 maxnames=3,
 maxbibnames=99 ,                
 uniquename=init ,
]{biblatex}
\bibliography{literature.bib}

\usepackage{ownstyle}


\author{Benedikt Ahrens}
\author{R\'egis Spadotti}

\title[Coinitial semantics for redecoration of triangular matrices]{Coinitial semantics \\ for redecoration of triangular matrices}
% Comodules over relative comonads for coinitial semantics
\newcommand{\fat}[1]{\textbf{#1}}

\begin{document}


\begin{abstract}
  Infinite triangular matrices and, in particular, the \emph{redecoration} operation on them, 
  were studied by \citeauthor{DBLP:conf/types/MatthesP11}. In their work,  redecoration is characterized
  as the cobind operation of what the authors call a \enquote{weak constructive comonad}.
  
  In this work, we identify weak constructive comonads as an instance of the more general notion of 
  \emph{relative comonad}.
  Afterwards, building upon the work by \citeauthor{DBLP:conf/types/MatthesP11}, we give a category-theoretic
  characterisation of infinite triangular matrices---equiped with the canonical bisimulation relation and a 
  compatible comonadic $\cobind$ operation---as the \emph{terminal object}
  in some category.
  
%   We give a category-theoretic characterisation of heterogeneous coinductive datatypes as terminal---\enquote{coinitial}---objects.
% 
%   For this, we develop the notion of \emph{comodule over a relative comonad} and provide some constructions of such comodules.

%   The right notion of sameness for terms of a coinductive datatype is not equality but \emph{bisimulation}.
%   Consequently, we model coinductive datatypes that are parametrized by a set not as a comonad on the category of sets,
%   but as a \emph{relative} comonad from sets to setoids, over a suitable functor.
\end{abstract}

\maketitle

% \tableofcontents

\section{Introduction}

 Simple inductive types---\textsf{W}-types---are characterised categorically as initial algebras of
 a polynomial functor \parencite{DBLP:journals/apal/MoerdijkP00}.
 Dually, infinite, \emph{coinductive} types are characterised as terminal \emph{co}algebras of suitable functors.
 In the case of coinductive types, the meta-theoretic notion of equality is not adequate. Another notion of sameness for inhabitants of such types, 
 \emph{bisimulation}, was introduced by \textcite{aczel_nonwellfounded}, and also
 a new proof principle called \emph{coinduction}. 
 Modulo this slight complication, it looks like it suffices to dualize the theory of inductive types in order to obtain
 a complete picture of coinductive types.
%  It turns out that the story is not that easy when considering \emph{heterogeneous} (co)inductive types:
 
 The characterisation of inductive types as initial algebras 
 has been extended to \emph{heterogeneous}---also called \emph{nested}---inductive datatypes, e.g., the type of $\lambda$-terms,
 in various formulations \parencite{fpt, DBLP:journals/iandc/HirschowitzM10}.
 The main goal of these works is not just to characterize the data type via a universal property, but rather the data type
 \emph{equiped with a well-behaved substitution operation}.
 
 
%  Such coinductive datatypes are characterised as terminal---coinitial---algebras of polynomial functors.

 In this work we set off to characterize a specific \emph{co}inductive heterogeneous datatype---the type family $\Tri$ of 
 infinite triangular matrices as studied by \textcite{DBLP:conf/types/MatthesP11}, equiped with a \emph{co}substitution operation---as a terminal object of some 
 category. For this, we start dualizing the approach by \textcite{DBLP:journals/iandc/HirschowitzM10}, where 
 the crucial notions are the notion of monad and, more importantly, \emph{module over a monad}.
 It turns out that more work than a simple dualization is necessary, for two reasons which we indicate in the following.
 
 

%  give an extension of the characterisation as terminal coalgebra to an instance of \emph{heterogeneous} coinductive types,
%  namely the coinductive datatype of infinite triangular matrices as studied by
%  \textcite{DBLP:conf/types/MatthesP11}. 
 
 The codata type family $\Tri$ of infinite triangular matrices is parametrized by a fixed set for entries not on the diagonal, 
 and indexed by another, \emph{variable}, set for entries on 
 the diagonal. The respective types of its specifying destructors $\head$ and $\tail$ are given in \Cref{fig:tri_destructors}.
 A first difference to the inductive case of the lambda calculus springs to mind:
 while the lambda calculus is essentially a monad---hence an \emph{endo}functor---on sets, the codata type $\Tri$ cannot be considered as such;
 for a given set $A$, the type $\Tri A$, equiped with a suitable \fat{bisimulation} relation, 
 constitutes a \emph{setoid}---a set equiped with an equivalence relation---rather than a set.
 Instead of considering comonads---as the dual notion to monads---we thus have to consider a notion of comonad whose underlying functor is not necessarily endo.
 This is precisely the raison d'\^etre of \emph{relative} comonads (defined below)---the dual notion to the relative monads defined in 
  \parencite{DBLP:conf/fossacs/AltenkirchCU10}. 
 Fortunately, relative comonads have all the nice properties we could ask for; 
 in particular, the notion of module over a monad of \parencite{DBLP:journals/iandc/HirschowitzM10} extends to modules over \emph{relative} monads
 \parencite{ahrens_relmonads}, which can be dualized to obtain comodules over relative comonads.
 
 The other, more important difference between the inductive and the coinductive case stems from \emph{heterogeneity}:
 Two dual operations are responsible for the heterogeneity of the data type of lambda terms and the codata type of infinite triangular
 matrices: while we precompose with taking a \emph{co}product in the case of the abstraction of the lambda calculus---in order to account
 for context extension when passing under a binder---,
 we precompose with taking a \emph{product} when giving the target of the $\tail$ destructor of $\Tri$.
 However, as it turns out, the treatment of the $\tail$ destructor is far more complicated than a dualization of that of the abstraction 
 constructor of the lambda calculus. Explaining our treatment is the main purpose of the present work.
 
%  Our extension is in the spirit of the work by \textcite{DBLP:journals/iandc/HirschowitzM10}, which uses the notion of \emph{monad} and
%  \emph{module over a monad} to characterize substitution.
%  However, in order to characterize the cosubstition---\emph{redecoration}---of infinite triangular matrices, 
%  a simple dualisation of that work is not sufficient: since coinductive datatypes such as the aforementioned matrices 
%  live naturally in the category of 
%  \emph{setoids}, i.e.\ of sets equiped with an equivalence relation---the \fat{bisimulation} relation---rather than in the category of sets,
%  comonads are not good enough; we need a notion of comonad where the underlying functor is not necessarily endo.
%  
%  The notion of module over a monad was generalized to relative monads in \parencite{ahrens_relmonads}.
%  In the present work, we dualize this generalization to obtain comodules over relative comonads, and use this gadget to 
%  give a category-theoretic characterisation of redecoration for infinite triangular matrices.
%  
%  At first glance, infinite triangular matrices look dual to, say, the lambda calulus as a heterogeneous datatype \parencite{DBLP:journals/iandc/HirschowitzM10}
%  in every aspect: 
%  . We have already mentioned a first aspect that makes the coinductive case more complicated: the need for 
%  \emph{relative} comonads rather than traditional comonads.
%  
%  Our framework should generalize to heterogeneous coinductive datatypes specified by signatures in the spirit of \parencite{ahrens_relmonads},
%  but we lack interesting examples other than the considered triangular matrices.
 
 All our definitions, examples and lemmas have been implemented in the proof assistant \texttt{Coq} \parencite{coq84pl3}.
 In this document, we hence omit the proofs and focus on definitions and statements of lemmas.
 
\subsection*{Organisation of the paper}
  In \Cref{sec:preliminaries} we introduce some concepts and notations used later on.
  In \Cref{sec:comonads} we define the category of comonads relative to a fixed functor.
  In \Cref{sec:comodules} we define comodules over relative comonads and give some constructions of comodules.
  In \Cref{sec:coalgebras_for_tri} we explain an important difference between the lambda calculus and infinite triangular matrices
    as heterogeneous data types. We then set up the necessary definitions to state our main theorem (\Cref{ex:final_sem_tri}), 
    characterizing the codata type $\Tri$ as terminal object in some category.
  In \Cref{sec:formal} we explain some details of the formalization of this work in the proof assistant \textsf{Coq}.
 
\section{Preliminaries}\label{sec:preliminaries}


\begin{definition}[Some categories]\label{def:set_setoid}
 We denote by $\Set$ the category of sets and total functions. 
 
 We denote by $\Setoid$ the category an object of which is a set equiped with an equivalence relation.
 A morphism between setoids is a set-theoretic function between the underlying sets that is compatible with the equivalence relations of the source and target setoids.
 Given a setoid $T$, we write $t\sim t'$ for related elements $t$ and $t'$ in $T$.
\end{definition}



\begin{definition}\label{def:eq}
 We define the functor $\eq : \Set\to\Setoid$ as the left adjoint to the forgetful functor 
  $U : \Setoid \to \Set$.
  Explicitly, the functor $\eq$ sends any set $X$ to the setoid $(X,=_X)$ given by the set $X$ itself, together
  with the equality relation $=_X$ on $X$.
\end{definition}


\begin{remark}[Notation for product]
  We denote the category-theoretic binary product of objects $A$ and $B$ of a category $\C$ by $A\times B$.
  We write $\pr_1(A,B) : \C(A\times B, A)$ and $\pr_2(A,B) :\C(A\times B, B)$ for the projections, and we omit the 
  argument $(A,B)$ when it is clear from the context.
  Given $f : \C(A, B)$ and $g : \C(A,C)$, we write $\langle f,g\rangle : \C(A,B\times C)$ for the induced map into the product such that
  $\comp{\langle f,g\rangle}{\pr_1} = f$ and $\comp{\langle f,g\rangle}{\pr_2} = g$.
\end{remark}

Both of the categories of \Cref{def:set_setoid} have binary products; they are \emph{cartesian monoidal}, i.e.\ the terminal 
object is neutral with respect to the multiplication. Functors preserving the monoidal structure \textbf{up to isomorphism}
are called \emph{strong monoidal}:

\begin{definition}[Strong monoidal functor]\label{def:monoidal_functor}
 A functor $F:\C\to\D$ between cartesian monoidal categories is \fat{strong monoidal} if, for any two objects $A$ and $B$ of $\C$,
  the morphism
 \[ \alpha^F_{A,B} := \bigl\langle F(\pr_1), F(\pr_2) \bigr\rangle : \D\bigl(F(A\times B), FA\times FB\bigr)\enspace  \] 
 is an isomorphisms.
 (Note that for \emph{cartesian} monoidal categories, the family $\alpha$ of morphisms automatically makes commute the 
  diagrams necessary to have a strong monoidal functor, since it is given by universal property. 
  We shall not need more general strong monoidal functors between arbitrary monoidal categories.)
\end{definition}

\begin{example}
  The functor $\eq: \Set \to \Setoid$ of \Cref{def:eq} is strong monoidal.
\end{example}


\section{Relative comonads and their morphisms}\label{sec:comonads}

\emph{Relative monads} were defined by \textcite{DBLP:conf/fossacs/AltenkirchCU10} as a notion of monad-like structure
whose underlying functor is not necessarily an endofunctor.
The dual notion is that of a relative \emph{co}monad:

\begin{definition}[Relative comonad]\label{def:rel_comonad}
  Let $F:\C\to\D$ be a functor. A \fat{relative comonad $T$ over $F$} is given by
  \begin{packitem}
   \item a map $T:\C_0 \to \D_0$ on the objects of the categories involved;
   \item an operation $\counit : \forall A : \C_0, \D(TA,FA)$;
   \item an operation $\cobind: \forall A,B:\C_0, \D(TA,FB) \to \D(TA,TB)$
  \end{packitem}
  such that 
  \begin{packitem}
   \item $\forall A,B:\C_0, \forall f:\D(TA,FB), \comp{\cobind(f)}{\counit_B} = f$;
   \item $\forall A : \C_0, \cobind(\counit_A) = \id_A$;
   \item $\forall A,B,C:\C_0, \forall f : \D(TA,FB),\forall g:\D(TB,FC), \\
        \comp{\cobind(f)}{\cobind(g)} = \cobind(\comp{\cobind(f)}{g})$.
  \end{packitem} 
\end{definition}
Just like relative monads, relative comonads are functorial:
\begin{definition}[Functoriality for relative comonads]\label{def:lift}
 Let $T$ be a  comonad relative to $F:\C\to\D$.
 For $f : \C(A,B)$ we define
  \[ \lift^T(f) := \cobind(\comp{\counit_A}{Ff}) .  \]
 The functor properties are easily checked.
\end{definition}
Relative comonads over the identity functor are exactly comonads.
A nontrivial instance of relative comonads is given by the coinductive datatype of infinite triangular matrices
studied by \textcite{DBLP:conf/types/MatthesP11}:


\begin{example}[\textcite{DBLP:conf/types/MatthesP11}]\label{ex:tri_comonad}
Let $E$ be an arbitrary fixed set.
   Infinite triangular matrices over the (variable) type $A$ are given by the destructors shown in \Cref{fig:tri_destructors},
    equiped with a coinductively defined equivalence relation, a \emph{bisimulation}.
    We write $t \sim t'$ for related matrices $t$ and $t'$.
%   \begin{lstlisting}
% Coinductive Tri (E : Set) : Set -> Set :=
%    head : forall A : Set, Tri (A) -> A.
%  | tail : forall A : Set, Tri (A) -> Tri (E x A).
%   \end{lstlisting}
% 

\begin{figure}[hbt]
  \begin{center}
    % \begin{minipage}{20em}
     \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t : \Tri(A)$}\doubleLine
     \UnaryInfC{$\head_A(t) : A$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t : \Tri(A)$}\doubleLine
                                       \UnaryInfC{$\tail_A(t) : \Tri(E\times A)$}
                                       \DisplayProof%
     % \end{minipage} 
  \end{center}
\vspace{2ex}
  \begin{center}
                                            \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t \sim t'$}\doubleLine
     \UnaryInfC{$\head(t) = \head(t')$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t \sim t'$}\doubleLine
                                       \UnaryInfC{$ \tail(t) \sim \tail(t')$}
                                       \DisplayProof   
  \end{center}
  \caption{Destructors and bisimulation for the coinductive family $\Tri$} \label{fig:tri_destructors}
\end{figure}
% \begin{figure}[tb]
%   \centering
% %   \fbox{
%                                             \def\extraVskip{3pt}
%      \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
%     \AxiomC{$t \sim t'$}\doubleLine
%      \UnaryInfC{$\head(t) = \head(t')$}
%       \DisplayProof
%                         \hspace{3ex}
%                                        \AxiomC{$t \sim t'$}\doubleLine
%                                        \UnaryInfC{$ \tail(t) \sim \tail(t')$}
%                                        \DisplayProof
%      % \end{minipage} 
% %        }
%   \caption{Bisimulation relation for $\Tri$} \label{fig:tri_bisim}
% \end{figure}
%

\noindent
\textcite{DBLP:conf/types/MatthesP11} define a notion of \emph{weak constructive comonad}, and show that the datatype $\Tri$
  is an instance of such a comonad. 
  Such a weak constructive comonad, however, is \emph{precisely}
  a comonad relative to the functor $\eq : \Set\to\Setoid$.
  The $\counit$ is given by the operation $\head$.
  The $\cobind$ operation---called \emph{redecoration} or $\redec$ in \parencite{DBLP:conf/types/MatthesP11}--- of type
   \[ \redec_{A,B} : \Setoid(\Tri A,\eq B) \to \Setoid(\Tri A,\Tri B )\] is defined 
  corecursively, for $f:\Setoid(\Tri A,\eq B)$  and $t : \Tri A$ by
      \begin{align}\head\bigl(\redec~f~t\bigr) &:= f~t \quad\text{ and } \notag\\
                     \tail\bigl(\redec~f~t\bigr) &:= \redec\bigl(\extend~f\bigr)(\tail~t) \enspace . \label{eq:rest_redec}
      \end{align}
Here, the family of functions 
     \[\extend_{A,B} : \Setoid(\Tri A,\eq B) \to \Setoid\bigr(\Tri (E \times A),\eq(E\times B)\bigr)\]
  is suitably defined to account for the change of the type of argument of $\redec$ when redecorating $\tail~t : \Tri(E\times A)$
  rather than $t : \Tri A$, namely
  \[ \extend(f) := \langle \comp{\head_{E\times A}}{\pr_1(E,A)} , \comp{\cut_A}{f} \rangle \enspace . \]
  The auxiliary function $\cut_A : \Tri(E\times A) \to \Tri A$ is defined corecursively via
   \begin{align*}\head\bigl(\cut~t\bigr) &:= \pr_2(\head~t) \quad\text{ and } \\
                     \tail\bigl(\cut~t\bigr) &:= \cut(\tail~t) \enspace . 
      \end{align*}
 Note that what is called $\extend$ here is called \textit{lift} in \parencite{DBLP:conf/types/MatthesP11}.
  
  
  
%   We refer to our implementation in the proof assistant \textsf{Coq} for the precise definition.
\end{example}






\begin{definition}[Morphism of relative comonads]\label{def:comonad_morphism}
 Let $T$ and $S$ be comonads relative to a functor $F : \C \to \D$. A \fat{morphism of relative comonads} $\tau : T \to S$
  is given by a family of morphisms \[\tau_A : \D(TA,SA)\] such that for any $A : \C_0$,
     \[  \counit^T_A = \comp{\tau_A}{\counit^S_A} \]
   and for any $A,B : \C_0$ and $f : \D(SA,FB)$,
   \[  \comp{\cobind^T(\comp{\tau_A}{f})}{\tau_B} = \comp{\tau_A}{\cobind^S(f)} \enspace .  \]
\end{definition}

A morphism $\tau : T\to S$ of relative comonads over a functor $F:\C\to\D$ is  \emph{natural}
with respect to the functorial action of \Cref{def:lift}.
% 
% \begin{remark}[Category of relative comonads]
%  Fix a functor $F : \C\to\D$. 
Relative comonads over a fixed functor $F$ and their morphisms form a category $\RComonad(F)$.
% \end{remark}

In the definition of the $\extend$ operation in \Cref{ex:tri_comonad} the auxiliary operation $\cut$ plays a central r\^ole.
It should be remarked here that, using functoriality of $\Tri$, one can define another operation of the same type, namely the family of 
maps $\Tri(\pr_2(E,A)) : \Tri(E\times A) \to \Tri A$ for
all sets $A$. Had we used this operation rather than the corecursively defined $\cut$ of \Cref{ex:tri_comonad}, 
then the third comonad law would have failed; we refer to \parencite{DBLP:conf/types/MatthesS07} for details.



\section{Comodules over relative comonads}\label{sec:comodules}

In this section we dualize the notion of module over a relative monad as developed in \parencite{ahrens_relmonads}.
This dualization is straightforward.


\begin{definition}[Comodule over relative comonad]\label{def:comodule}
 Let $T$ be a relative comonad over the functor $F:\C\to\D$, and let $\E$ be a category.
 A \fat{comodule over T towards $\E$} consists of
   \begin{packitem}
   \item a map $:\C_0 \to \E_0$ on the objects of the categories involved;
   \item an operation $\mcobind: \forall A,B:\C_0, \D(TA,FB) \to \E(MA,MB)$
  \end{packitem}
  such that 
  \begin{packitem}
   \item $\forall A : \C_0, \mcobind(\counit_A) = \id_A$;
   \item $\forall A,B,C:\C_0, \forall f : \D(TA,FB),\forall g:\D(TB,FC), \\
        \comp{\mcobind(f)}{\mcobind(g)} = \mcobind(\comp{\cobind(f)}{g})$ .
  \end{packitem}

\end{definition}

Every relative comonad comes with a canonical comodule over it, the \emph{tautological comodule}:

\begin{definition}[Tautological comodule]\label{def:tautological_comodule}
  Given a comonad $T$ relative to $F:\C\to\D$, the assignment $A \mapsto TA$ yields a comodule over $T$ 
  with target category $\D$, the \textbf{tautological comodule} of $T$, also called $T$.
  The comodule operation is given by
    \[  \mcobind^T(f) := \cobind^T(f) \enspace . \]
\end{definition}


A \emph{morphism of comodules} is given by a family of morphisms that is compatible with 
the comodule operation:

\begin{definition}[Morphism of comodules]\label{def:morphism_of_comodules}
 Let $M, N : \C \to \E$ be comodules over the comonad $T$ relative to  $F:\C \to \D$.
 A \fat{morphism of comodules} from $M$ to $N$ is given by a family of morphisms 
   \[ \alpha_A:\E(MA,NA) \]
 such that for any $A,B:\C_0$ and $f : \D(TA,FB)$ one has
 \[   \comp{\mcobind^M(f)}{\alpha_B} = \comp{\alpha_A}{\mcobind^N(f)} \enspace . \]
\end{definition}


Composition and identity of comodule morphisms happens pointwise. We thus obtain a category of comodules
over a fixed comonad, towards a fixed target category:

\begin{remark}[Category of comodules]
 Fix a comonad $T$ relative to $F:\C\to\D$ and a category $\E$.
 Comodules over $T$ towards $\E$ and their morphisms  form a category $\RComod(T,\E)$.
\end{remark}

Similarly to relative comonads, comodules over these are functorial:

\begin{definition}[Functoriality for comodules]\label{def:comodule_lift}
 Let $M : \RComod(T,\E)$ be a comodule over $T$ towards some category $\E$. For $f : \C(A,B)$ we define
  \[ \mlift^S(f) := \mcobind(\comp{\counit_A}{Ff}) .  \]
\end{definition}


\begin{remark}
  The family of morphisms constituting a comodule morphism is actually natural with respect to the functoriality 
  defined in \Cref{def:comodule_lift}.
\end{remark}

Given a morphism of comonads, we can \enquote{transport} comodules over the source comonad to comodules over the target comonad:


\begin{definition}[Pushforward comodule]\label{def:pushforward_comodule} % checked
  Let $\tau : T\to S$ be a morphism of comonads relative to a functor $F : \C \to \D$, and let furthermore $M$ be a 
  comodule over $T$ towards a category $\E$. We define the \fat{pushforward comodule} $\tau_*M$ to be the comodule over $S$ given by
  \[  \tau_*M(A) := MA \]
  and, for $f : \D(SA,FB)$,
   \[ \mcobind^{\tau_*M}(f) := \mcobind^M(\comp{\tau_A}{f}) \enspace . \]
   
  \noindent
  Pushforward is functorial: if $M$ and $N$ are comodules over $T$ with codomain category $\E$, and $\alpha : M\to N$ is 
    a morphism of comodules, then we define \[\tau_*\alpha : \tau_*M \to \tau_*N\] 
    as the family of morphisms
     \[ (\tau_*\alpha)_A := \alpha_A \enspace . \]
  It is easy to check that this is a morphism of comodules (over $S$) between $\tau_*M$ and $\tau_*N$.
  Pushforward thus yields a functor $\tau_*:\RComod(T,\E) \to \RComod(S,\E)$.
\end{definition}


\begin{definition}[Morphism of comonads induces morphism of comodules] % checked
  Let $\tau : T\to S$ be a morphism of comonads relative to a functor $F : \C \to \D$.
  Then $\tau$ gives rise to a morphism of comodules over $S$ from the pushforward of the tautological comodule
  of $T$ along $\tau$ to the tautological comodule over $S$,
  \[ \induced{\tau} : \tau_*T \to S \enspace , \quad \induced{\tau}_A := \tau_A \enspace . \]
\end{definition}




\section{Coalgebras for infinite triangular matrices}\label{sec:coalgebras_for_tri}


Our goal is to define \fat{coalgebras} for the signature of infinite triangular matrices such that 
the codata type $\Tri$ defined in \Cref{ex:tri_comonad} constitutes the \fat{terminal such coalgebra}.
Since $\Tri$ forms a comonad relative to the functor $\eq:\Set\to\Setoid$, it seems reasonable to define
an arbitrary coalgebra as such a relative comonad as well, equiped with some extra structure which remains to be defined.
A morphism of coalgebras would then be defined as a morphism of relative comonads that is compatible with that extra structure.

The purpose of this extra structure is to characterize the destructor $\tail$, that is, its \emph{type} as well as
its \emph{behaviour with respect to the redecoration operation}.



\begin{remark}[$\tail$ is not a morphism of comonads]
At first glance, one might hope for $\tail$ to constitute the carrier of a morphism of relative comonads, i.e.\ one might 
guess that the axioms of comonad morphism capture the commutativity of $\tail$ with the operations $\head$ and $\tail$:
  Let $T$ be a comonad relative to a strong monoidal functor $F:\C\to\D$ between cartesian monoidal categories,
  and let $E:\C_0$ be a fixed object of $\C$.
 The map $A\mapsto T(E\times A)$ inherits the structure of a comonad relative to $F$ from $T$: the 
 counit is defined as
   \[ \counit^{T(E\times \_)}_A := \comp{\counit^T_{E\times A}}{F\pr_2(E,A)} \]
  and the cobind operation as
   \begin{align*} 
            \cobind^{T(E\times \_)}_{A,B} : \D\bigl(T(E\times A),FB\bigr) &\to \D\bigl(T(E\times A),T(E\times B)\bigr) \\
%              \cobind^{T(E\times \_)}_{A,B}
              f &\mapsto  \cobind^T(\extend'~f)
   \end{align*}
  with $\extend'$ defined as 
  \begin{align*} \extend' : \D\bigl(T(E\times A),FB\bigr) &\to \D\bigl(T(E\times A), F(E\times B)\bigr) \enspace , \\ 
                                            f & \mapsto \comp{\langle \comp{T(\pr_1)}{\counit^T_E}, f \rangle}{{\alpha^{F}_{E,B}}^{-1}} \enspace .
  \end{align*}
 One might thus try to characterize the destructor $\tail$ of the triangular matrices of \Cref{ex:tri_comonad}
 as a morphism of relative comonads, of type $\Tri \to \Tri(E\times \_)$.
 However, this fails for similar reasons as for heterogeneous inductive datatypes, see \parencite[Ex.\ 3.18]{ahrens_zsido}.
 %TODO: give explicit counterexample
\end{remark}


We now take a closer look at how the $\extend$ operation for $\Tri$ is defined. Its purpose is to 
modify the function $f$ used for redecoration, when redecorating $\tail~t : \Tri(E\times A)$ rather than $t : \Tri A$.
First we note an important difference between the $\extend$ operation and its analogue in the inductive case:

\begin{remark}[$\shift$ operation for the lambda calculus]
  The heterogeneous data type of lambda terms comes with a term constructor $\abs_A : \ULC(A^*) \to \ULC A$, which 
  is the constructor responsible for the heterogeneity of that data type.
  We compare the $\extend$ operation to the one with analogue purpose in the case of the lambda calculus,
  the $\shift$ operation, of type
  \begin{equation}  \shift_{A,B} : \Set(A,\ULC B) \to \Set\bigl(A^*,\ULC(B^*)\bigr) \enspace .\label{eq:shift}\end{equation}
  Here $\ULC A$ denotes the set of lambda terms in context $A$, and $A^*:=1 + A$ denotes the context $A$ extended by a distinguished 
  variable---the variable bound by the abstraction constructor.
  
  The $\shift$ operation is used in the definition of the monadic substitution operation
  \[ \subst_{A,B} : \Set(A,\ULC B) \to \Set(\ULC A,\ULC B) \]
  of the lambda calculus, when recursively substituting under an abstraction:
   \[ \subst~f~(\abs~t):= \abs\bigl(\subst~(\shift~f)~t\bigr) \enspace . \]
  The reader is encouraged to compare this equation to \Cref{eq:rest_redec}.
  
  The $\shift$ operation can be defined in monadic terms, for any monad $T$ on the category of sets such that,
  when $T$ is instantiated by the monad $\ULC$, it becomes the specific $\shift$ operation of \Cref{eq:shift}.
  
  However, we were \emph{not} able to express the $\extend$ operation of $\Tri$ entirely in terms of categorical and comonadic operations. Indeed, if
  one dualizes the categorical definition of $\shift$, one obtains an operation that has the same type as $\extend$, 
  but for which, when used to define the redecoration, some comonadic property of redecoration fails.
  More specifically, it is the auxiliary $\cut$ operation as defined in \Cref{ex:tri_comonad} which does not seem to be 
  definable in categorical terms. There is an operation of the same type which is categorical---see \Cref{canonical_cut}---but
  which, when used for the definition of the $\extend$ operation, yields a \enquote{redecoration} operation for which the third comonad law fails.
  Details are given in an article by \textcite{DBLP:conf/types/MatthesS07}.
\end{remark}


The failure to describe the $\extend$ operation---more precisely, the auxiliary $\cut$---in categorical terms leads us 
to considering comonads that come with a specified $\cut$ operation for some fixed object $E$ in the source category:


% In what follows, we fix an object $E$ of the category $\C$.


% For an arbitrary comonad $T$ relative to a suitable functor $F$, an analogue operation $\cut^T_A : \D(T(E\times A),TA)$
% does not seem to be deducible from 



\begin{definition}[Relative comonad with cut]\label{def:rel_comonad_with_cut}
 Let $\C$ and $\D$ be categories with binary products and $F:\C\to\D$ a strong monoidal functor. Let $E:\C_0$ be a fixed object of $\C$.
 We define a \fat{comonad relative to $F$ with cut relative to $E$} to be a comonad $T$ relative to $F$ together with a $\cut$ operation 
    \[ \cut : \forall~A:\C_0, T(E\times A) \to TA \]
 satisfying the following axioms:
  \begin{itemize}
   \item $\forall~A:C_0, \comp{\cut_A}{\counit_A} = \comp{\counit_{E\times A}}{F(\pr_2(E,A))}$;
   \item $\forall~A~B:C_0,\forall~f:\D(TA,FB), \comp{\cut_A}{\cobind(f)} = \comp{\cobind(\extend~f)}{\cut_B}$,
  \end{itemize}

  \noindent
  where, for $f:\D(TA,FB)$, we define $\extend(f) : \D\bigl(T(E\times A),F(E\times B)\bigr)$ as
       \[ \extend(f) := \comp{\comp{\langle T(\pr_1) , \cut \rangle}{(\counit_E\times f)}}{{\alpha^{F}_{E,B}}^{-1}} \enspace . \]
  
\end{definition}

Morphisms of comonads with cut are morphisms of comonads that are compatible with the respective $\cut$ operations:

\begin{definition}[Morphism of comonads with cut]\label{def:morphism_comonad_cut}
 Let $T$ and $S$ be two comonads relative to a functor $F$ with cut relative to $E$ as in \Cref{def:rel_comonad_with_cut}.
 A \emph{morphism of comonads with cut} is a comonad morphism $\tau$ between the underlying comonads as in \Cref{def:comonad_morphism} that 
 commutes suitably with the respective $\cut$ operations, i.e.\ for any $A : \C_0$,
  \[ \comp{\tau_{E \times A}}{\cut^S_A}  = \comp{\cut^T_A}{\tau_A} \enspace . \]
%  TODO: where is tau_cut used?
\end{definition}


Comonads with cut relative to a fixed functor $F:\C\to\D$ and $E:\C_0$ form a category $\RComonadWC(F,E)$.
There is the obvious forgetful functor from $\RComonadWC(F,E)$ to $\RComonad(F)$.
Conversely, any comonad $T$ relative to a suitable functor can be equiped with a $\cut$ operation, using functoriality of $T$:



\begin{remark}[Canonical $\cut$ operation]\label{canonical_cut}
 Any comonad $T$ relative to a functor $F$ as in \Cref{def:rel_comonad_with_cut} can be equiped with a $\cut$ operation by setting
   \[ \cut^T_A := \lift^T\bigl(\pr_2(E,A)\bigr) \enspace . \]
 It follows from the axioms of comonad morphism that a comonad morphism $\tau : T\to S$ satisfies the equation of \Cref{def:morphism_comonad_cut} 
 for the thus defined operations $\cut^T$ and $\cut^S$, hence constitutes a morphism of comonads with cut from $(T,\cut^T)$ to $(S,\cut^S)$.
\end{remark}

The functor given by the canonical $\cut$ operation, followed by the forgetful functor, yields the identity. We can thus view
relative comonads with cut as a generalization of relative comonads.

Our prime example of relative comonad comes with a $\cut$ operation that is not the canonical one:

\begin{example}[$\cut$ for $\Tri$]\label{def:cut_for_tri}
  The relative comonad $\Tri$ from \Cref{ex:tri_comonad}, together with the $\cut$ operation defined there, 
  is a comonad with cut as in \Cref{def:rel_comonad_with_cut}.
\end{example}















\begin{comment}
\begin{definition}[IS ALREADY IN rel comonad with cut]\label{def:extend}
 Let $F : \C\to \D$ be a strong monoidal functor between (cartesian) monoidal categories, 
 i.e.\ we have a family of isomorphisms
  \[ \alpha_{A,B} : F(A\times B) \xrightarrow{\sim} FA\times FB\enspace . \] 
  Let $T$ be a relative comonad over $F$, and let $E : \C$ be an object of $\C$.
 We define
 \begin{align*} \extend_{A,B} : \D(TA,FB) &\to \D\bigl(T(E\times A),F(E\times B)\bigr)\\
                                   f   &\mapsto \comp{\bigl\langle \comp{\counit_{E\times A}}{\comp{\alpha_{E,A}}{\pr_1(FE,FA)}}, \comp{\lift(\pr_2(E,A))}{f} \bigr\rangle}{\alpha_{E,B}^{-1}} \enspace .
\end{align*}
% with 
% \begin{align*}
%                \cut_A: \C(T(E\times A), TA), \quad \cut_A := \cobind_{E \times A, A}(\comp{\counit_{E \times A}}{\pr_1}) \enspace .
% \end{align*}

Equivalently,
  \[ f   \mapsto \comp{\comp{\langle T(\pr_1) , T(\pr_2) \rangle}{(\counit_E\times f)}}{\alpha_{E,B}^{-1}} \enspace .
  \]

  
Equivalently,
  \[ f   \mapsto \comp{\langle \comp{T(\pr_1)}{f} , F(\pr_2) \rangle}{\alpha_{E,B}^{-1}} \enspace .
  \]
  
Equivalently,
  \[f  \mapsto \comp{\bigl\langle \comp{\counit_{E\times A}}{F(\pr_1(E,A))}, \comp{\lift(\pr_2(E,A))}{f} \bigr\rangle}{\alpha_{E,B}^{-1}} \enspace .
  \]
\end{definition}
\end{comment}



Given a comodule over a relative comonad with cut, we define a new comodule over the same comonad, given by precomposition with
\enquote{product with a fixed object $E$}:


\begin{definition}[Precomposition with product]\label{def:product_in_context}
 Suppose $F:\C\to\D$ is a strong monoidal functor, and $T$ is a comonad relative to $F$ with a $\cut$ operation 
 relative to $E:\C_0$ as in \Cref{def:rel_comonad_with_cut}.
 Given a comodule $M$ over $T$,  precomposition with \enquote{product with $E$}
 gives a comodule $M(E\times\_)$ over $T$,
  \[    M(E\times \_) : A \mapsto M(E\times A) \enspace . \]
 The comodule operation is deduced from that of $M$ by 
 \begin{align*} \mcobind^{M(E\times\_)}_{A,B} : \D(TA,FB)&\to \E\bigl(M(E\times A), M(E\times B)\bigr) \enspace ,\\
                                                      f &\mapsto \mcobind^M_{E\times A,E\times B}(\extend(f)) \enspace ,
  \end{align*}                                        
where the $\extend$ operation is the one defined in \Cref{def:rel_comonad_with_cut}.
 
 Furthermore, given two comodules $M$ and $N$ over $\T$ with target category $\E$, and a comodule morphism $\alpha : M \to N$, then 
 we can define a comodule morphism \[\alpha(E\times \_) : M(E\times \_) \to N(E\times \_) \] by setting
          \[ \alpha(E \times \_)_A := \alpha_{E\times A} \enspace . \]
  
  \noindent
  We thus obtain an endofunctor on the category of comodules over $T$ towards $\E$,
   \[ M \mapsto  M (E\times \_) : \RComod(T,\E) \to \RComod(T,\E) \enspace . \]
\end{definition}






\begin{example}[$\tail$ is a comodule morphism]\label{ex:tail_comodule}
 Consider the comonad $\Tri$, equiped with the $\cut$ operation of \Cref{def:cut_for_tri}.
 The destructor \constfont{\tail} of \Cref{ex:tri_comonad} is a morphism of comodules over the comonad $\Tri$ 
  from the tautological comodule  $\Tri$ to $\Tri(E\times \_)$.
\end{example}







\begin{remark}[Pushforward commutes with product in context]\label{rem:prod_pullback_commute}
 Note that the constructions of \Cref{def:product_in_context} and \Cref{def:pushforward_comodule} commute in the sense that
 we have an isomorphism of comodules \[\tau_*(M(E\times \_)) \cong (\tau_*M)(E \times \_) \enspace . \]
\end{remark}


We now have all the ingredients to state (and prove) our main theorem:

\begin{theorem}[Coinitial semantics for triangular matrices with redecoration]\label{ex:final_sem_tri} % checked
   Let $E:\Set_0$ be a set.
   Let $\mathcal{T} = \mathcal{T}_E$ be the category where an object consists of
   \begin{itemize}
    \item a comonad $T$ over the functor $\eq:\Set\to\Setoid$ with cut relative to $E$ and
    \item a morphism $\tail$ of comodules over $T$ of type $T \to T(E\times \_)$
   \end{itemize}
   such that for any set $A$,
    \[ \comp{\cut^T_A}{\tail_A} = \comp{\tail_{E\times A}}{\cut^T_{E\times A}} \enspace . \]

   
   
   A morphism between two such objects $(T,\tail^T)$ and $(S,\tail^S)$
%    
% %    pair $(T,t)$ of a relative comonad $T$ over the functor
% %    $\eq: \Set \to \Setoid$ together with a morphism of comodules $t : T \to T(E \times \_)$.
%    A morphism $\tau : (T,t) \to (S,s)$ 
%    
%    
   is given by a morphism of relative comonads with cut $\tau : T \to S$ such that
   the following diagram of comodule morphisms in the category $\RComod(S,\E)$ commutes,
   
%    \[     \comp{\tau_*t}{\tau(E\times \_)} = \comp{\tau}{s} \enspace , \]
%    i.e.\, diagrammatically,   
   \[ \begin{xy}
       \xymatrix{   \tau_*T  \ar[r]^{\tau_*(\tail^T)} \ar[d]_{\induced{\tau}}  &  **[r] \tau_*T (E\times \_ )\ar[d]^{\induced{\tau}(E\times \_)} \\
                    S  \ar[r]_{\tail^S}  &  **[r] S (E\times \_ ) \enspace .
        }
      \end{xy}
   \]

   \noindent
   Here in the upper right corner we silently insert an isomorphism as in \Cref{rem:prod_pullback_commute}.
   
   Then the pair $(\Tri, \tail)$ consisting of the relative comonad with cut $\Tri$ of \Cref{def:cut_for_tri} together with 
    the morphism of comodules $\tail$ of \Cref{ex:tail_comodule},
   constitutes the terminal---\enquote{coinitial}---object in this category.
   
\end{theorem}



\begin{comment}

\section{Some more comodules}

In the following we present some more constructions of comodules which can be used to specify the type of 
destructors.



% \begin{definition}[Constant comodule]
%   Given $e:\E_0$, the function $\C_0\to\E_0$ sending any object of $\C$ to $e$ is equiped with
%   the structure of a comodule over $T$.
% \end{definition}


% \begin{definition}[Product comodule]
%  Given two comodules $M,N$ over $T$, then the pointwise product is equiped with the structure of 
%  a comodule over $T$.
% \end{definition}


Precomposition with \enquote{product with $E$} as in \Cref{def:product_in_context} is a special case of the following
general construction:

\begin{definition}[Precomposition with a functor]
  Let $T$ be a comonad relative to $F:\C\to\D$. 
  Let $K : \C\to\C$ be an endofunctor, and $K' : \D\to\D$ be another one, and let 
  $\alpha : TK \to K'T$ and $\beta : K'F \to FK$ be natural transformations.
  We then define
  \begin{align*} \extend_K : \D(TA,FB) &\to \D(TKA,FKB)  \enspace , \\ 
                                  f  &\mapsto \comp{\alpha_{A}}{\comp{K'f}{\beta_B}}  \enspace .
  \end{align*}
%
  Any comodule $M$ over $T$ with target category $\E$ then yields a comodule $MK$ with comodule operation
  \[ \mcobind^{MK}(f) := \mcobind^M(\extend_K(f)) \enspace . \]
\end{definition}

\begin{definition}[Postcomposition with a functor]\label{def:postcomposition_functor}
  Let $T$ be a comonad relative to $F:\C\to\D$, and let $M$ be a comodule over $T$ with codomain category $\E$.
 Let $K : \E \to \X$ be a functor. Then we define the comodule $KM$ to be the comodule over $T$ with codomain category $\X$
  sending any object $A:\C_0$ to $K(MA)$.
  The comodule operation is defined by
  \[ \mcobind^{KM}(f) := K (\mcobind(f)) \enspace . 
  \]
\end{definition}

\begin{example}[Infinite branching trees]
  Let $B$ a set. We consider $B$ as a setoid via the functor $\eq:\Set\to\Setoid$, which we silently apply.
  The hom functor $Y \mapsto \Setoid(B,Y)$ is an endofunctor on the category $\Setoid$: for any two setoids $X,Y$, 
   the set of setoid morphisms $\Setoid(X,Y)$ is itself equiped with an equivalence relation.
   Branching is given by postcomposition (\Cref{def:postcomposition_functor}) with such a hom functor.
\end{example}
\end{comment}




\section{Formalization in \texttt{Coq}}\label{sec:formal}

All our definitions and theorems are mechanized in the proof assistant \texttt{Coq} \parencite{coq84pl3}.
In the following we explain some of our design choices for this mechanization
and point out differences between the pen-and-paper definitions and the mechanized ones.



\subsection{Implementation choices}



\subsubsection{Setoids}

We choose to implement categories using \fat{setoids} for the dependent family of morphisms, as was first done by
\textcite{aczel_galois} in the proof assistant \texttt{LEGO}, and also used by \textcite{concat} in their library
of category theory in \texttt{Coq}.
The reason for this choice is explained in \parencite[Sec.\ 3.1.2]{ahrens_zsido}.

This choice is encouraged also by our use of a version of the \texttt{Coq} theorem prover which features \fat{universe polymorphism},
allowing to use a definition of setoids where the carrier is a \emph{field} rather than a \emph{parameter}.
% TODO: give code
In comparison, in the work by \textcite{concat}, the definitions of setoids and categories had to be repeated in order to avoid
universe inconsistencies.
As a side note, the universe polymorphism in the \texttt{Coq} version we use also allows to define the category of categories, even though
we do not make any use of that.

\subsubsection{Records vs.\ classes}

\subsection{Formal vs.\ informal definitions}


The biggest discrepancy between formal and informal definition arises in the construction of the terminal object itself:
in \textsf{Coq}, coinductive types are specified through \fat{constructors} rather than \fat{destructors}.
Work on the the declaration of coinductive types via destructors is done in \textsf{Agda}, cf.\ \parencite{DBLP:conf/popl/AbelPTS13}.

\section{Conclusions and future work}



We have given a category-theoretic characterisation, via a universal property, of infinite triangular matrices
equiped with a comonadic redecoration operation.

While a significant part of our work---surmounting the non-categoricity of the $\cut$ operation---seems to be specific to this particular codata type,
we believe that our work proves the suitability of the notion of relative (co)monads and (co)modules thereover for 
a categorical treatment of coinductive data types.


We plan to pursue two obvious lines of work:
Firstly, we will work on a suitable notion of \emph{signature} for the specification of coinductive data types.
Secondly, we hope to integrate \emph{equations} into the notion of signature, equations which 
will allow, e.g, considering branching trees modulo permutation of subtrees.
 

\subsection*{Acknowledgments}
 We thank Ralph Matthes and Paige North for awesome discussions about stuff.

\printbibliography

% \newpage
\appendix

\input{formal_table}

\end{document}


%TODO: other arities, e.g.
%    - T(A) ---->  (E -> T(A))
%    - http://www2.tcs.ifi.lmu.de/~rodrigue/docs/types.html


















