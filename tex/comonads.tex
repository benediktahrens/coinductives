

\pdfoutput=1

\documentclass{amsart}

\usepackage[utf8]{inputenc}

\usepackage[protrusion=true,expansion=true]{microtype}


\usepackage[style=numeric,
 backref=true,
 isbn=false,
 maxnames=3,
 maxbibnames=99 ,                
 uniquename=init ,
]{biblatex}
\bibliography{literature.bib}

\usepackage{ownstyle}


\author{Benedikt Ahrens}
\author{R\'egis Spadotti}

\title[Comodules over relative comonads]{Comodules over relative comonads \\ for streams and infinite matrices}

\newcommand{\fat}[1]{\textbf{#1}}


\begin{document}


\begin{abstract}


 In this work, we study the notions of \emph{relative comonad} and \emph{comodule over a relative comonad}, and  
 use these notions to give a terminal coalgebra semantics for coinductive type families in 
 intensional Martin-L\"of type theory.
 
    
%   Our main examples come from families of coinductive data types in intensional Martin-L\"of type theory.
%   We present a particular, heterogeneous such data type and prove a terminal semantics result for that type family,
%   based on the notion of comodules over relative comonads.
  
  

%   The heterogeneous codata type of infinite triangular matrices in intensional Martin-L\"of type theory and, 
%   in particular, the \emph{redecoration} operation on it, 
%   were studied by \citeauthor{DBLP:conf/types/MatthesP11}. In their work,  redecoration is characterized
%   as the cobind operation of what the authors call a \enquote{weak constructive comonad}.
%   
%   In this work, we identify weak constructive comonads as an instance of the more general notion of 
%   \emph{relative comonad}.
%   Afterwards, building upon the work by \citeauthor{DBLP:conf/types/MatthesP11}, we give a category-theoretic
%   characterization of infinite triangular matrices---equipped with the canonical bisimilarity relation and a 
%   compatible comonadic $\cobind$ operation---as the \emph{terminal object}
%   in some category.
  
  Our results are fully mechanized in the proof assistant \coq.
  \end{abstract}

\maketitle

\tableofcontents

\section{Introduction}
 
 In this work, we study the notions of \emph{relative comonad} and \emph{comodule over a relative comonad}.
 We then use these notions to characterise several coinductive data types in intensional Martin-L\"of type theory
 via a universal property.
 
 Relative monads were introduced by \textcite{DBLP:conf/fossacs/AltenkirchCU10} as a generalization of the notion of monad,
 to capture monadic structure on functors that are not necessarily endo.
 Examples of relative monads include finite-dimensional vector spaces, 
 lambda terms over finite sets \parencite{DBLP:conf/fossacs/AltenkirchCU10} as functors from finite sets to sets,
 or lambda terms equipped with a reduction preorder \parencite{ahrens_relmonads} as a functor from sets to preordered sets.
 
 One purpose of the present work is to present some applications of the dual notion of relative \emph{co}monad in intensional Martin-L\"of 
 type theory (IMLTT). More precisely, we equip some \emph{co}inductive type families with a relative comonadic structure.
 While inductive types are specified by \emph{constructors}---ways to build canonical elements of those types---, coinductive types
 are specified by \emph{destructors}. Destructors specify what can be observed from an inhabitant of such a coinductive type.
 
 For each type in IMLTT, there is an identity type for that type, a dependent type that constitutes the least reflexive relation on inhabitants on that type. 
 For inhabitants of an inductive type, this identity type yields the right notion of \enquote{sameness}. 
 For \emph{co}inductive types, however, the corresponding identity types do not reflect \enquote{sameness} appropriately.
 Instead, another notion of sameness for inhabitants of such types, 
 \emph{bisimilarity}, was coined by \textcite{aczel_nonwellfounded}. 
 Intuitively, two inhabitants of a coinductive type are the same if they allow for the same observations.
 
 Bisimilarity on a coinductive type is an equivalence relation and is determined by the \emph{signature} of that type. 
 A signature abstractly specifies the type of each destructor of the coinductive type it determines. 
 We thus
 consider coinductive types canonically equipped with an equivalence relation, i.e.\ as \emph{setoids}.	
 For instance, we consider the codata type of streams in IMLTT as a functor 
 $\stream : \Set \to \Setoid$, mapping a type $A$ to the setoid of streams over $A$.
 
%  Coinductive type families in IMLTT, parametrized by a type variable, are naturally considered not as an endofunctor
%  but as a functor from types to \emph{setoids}:
%  the equality relation given by Martin-L\"of's identity type does not yield an adequate notion of \enquote{sameness} for inhabitants of such coinductive types.
%  Instead, another notion of sameness for inhabitants of such types, 
%  \emph{bisimilarity}, was coined by \textcite{aczel_nonwellfounded}. 
%  We thus consider such codata types as \emph{setoids}, that is, as types equipped with an equivalence relation---bisimilarity---rather than 
%  just as plain types.
%  For instance, we consider the codata type of streams in IMLTT as a functor 
%  $\stream : \Set \to \Setoid$, mapping a type $A$ to the setoid of streams over $A$.

 The codata types we consider are parametrized by a type variable and come with a canonical \emph{cosubstitution operation}. 
 The main purpose of this work is to give a categorical characterisation
 of this operation. For this, we develop the notion of \emph{comodule over a relative comonad}: \emph{morphism of comodules} capture the interplay between 
 the destructors and the canonical cosubstitution on the considered codata types.
 This constitutes a generalization and dualization of work by \textcite{DBLP:journals/iandc/HirschowitzM10},
 who use \emph{modules over (plain) monads} to characterise the interplay of constructors and substitution of certain inductive data types.
 
 For a coinductive type family $T(A)$ with a type parameter $A$, one distinguishes \emph{homogeneous} and \emph{heterogeneous} destructors.
 While for a homogeneous destructor, the output type has the same type parameter as the input type, 
 heterogeneous destructors output a term of the coinductive type $T$ with a \emph{bigger} type parameter, say, $f(A)$ for some map $f$ on types.
 In this work we codata types both with homogeneous as well as heterogeneous destructors. 
 
 Finally, we give a final coalgebra semantics for the considered codata types, which does not only characterise the terms of those data types,
 but also the bisimilarity relation on those terms, and the canonical cosubstitution operation.
  
%  As an application, we define a map between two of our example codata types as a terminal coalgebra morphism.
  
%  In \emph{extensional} type theory, simple inductive types---\textsf{W}-types---are characterized categorically as initial algebras of
%  a polynomial functor \parencite{DBLP:journals/tcs/Dybjer97, DBLP:journals/apal/MoerdijkP00}.
%  In this context, the need for an extensional type theory is given by the need to identify maps as equal if they are equal on each input.
%  
%  The characterization of inductive types as initial algebras 
%  has been extended to some \emph{heterogeneous}---also called \emph{nested}---inductive data types, e.g., the type of $\lambda$-terms,
%  in various formulations \parencite{fpt, DBLP:journals/iandc/HirschowitzM10}.
%  The main goal of these works is not just to characterize the data type via a universal property, but rather the data type
%  \emph{equipped with a well-behaved substitution operation}.
%  
  
%  In this work we study a particular heterogeneous family of \fat{co}inductive data types in Intensional Martin-L\"of type theory.
%   For the study of such coinductive types, the built-in notion of \emph{propositional equality via Martin-L\"of identity types} is not adequate. 
%  Another notion of sameness for inhabitants of such types, 
%  \emph{bisimilarity}, was coined by \textcite{aczel_nonwellfounded}.
%  We first define a structure of \emph{relative comonad} whose underlying is given by the codata type family in question. 
%  Afterwards, we define a notion of \emph{coalgebra} for the signature of that codata type, and show that the category of
%  such coalgebras has a terminal object, built from the codata type.
%  
 All our definitions, examples and lemmas have been implemented in the proof assistant \coq \parencite{coq84pl3}.
 The \coq source files and HTML documentation are available on the project web page \parencite{trimat_coq}.
 In this document, we hence omit the proofs and focus on definitions and statements of lemmas.
 
 
 \subsection*{Disclaimer}The category-theoretic concepts studied in this work are agnostic to the foundational system being worked in.
 While we present them in a type-theoretic style, the definitions and lemmas can trivially be transferred to a set-theoretic setting.
 Throughout this article, we use type-theoretic notation,  writing $t:T$ to indicate that $t$ is of type $T$. 
 For instance, we write $f : \C(A,B)$ to indicate that $f$ is a morphism from object $A$ to object $B$ in category $\C$.
 Whenever an operation takes several arguments, we write some of them as indices; these indices might be omitted when 
 they can be deduced from the type of the later arguments.
 We assume basic knowledge of category theory; any instances used are defined in the following.
  
 \subsection*{Related work}
 The notion of \emph{module over a monad}, which we dualize and generalize in this work, is used by \textcite{DBLP:journals/iandc/HirschowitzM10}
 to give an initial semantics result for languages with variable binding. 
 Their work it is based on work by \textcite{alt_reus},
 who show that the lambda calculus equipped with a simultaneous substitution constitute a monad on the category of sets (or types).
 
 We make use of the notion of \emph{relative comonad}, the dual to relative monads as introduced by \textcite{DBLP:conf/fossacs/AltenkirchCU10}.
 Traditional comonads for functional programming with homogeneous codata types are studied by \textcite{DBLP:conf/sfp/UustaluV01}.
 
 One of our main examples, the codata type of infinite triangular matrices, is studied by \textcite{DBLP:conf/types/MatthesP11}.
 Redecoration for both finite and infinite triangular matrices is used by \textcite{DBLP:journals/tcs/AbelMU05} to exemplify 
 the expressivity of the studied recursion schemes.
 
 
 \subsection*{Organisation of the paper}
  In \Cref{sec:preliminaries} we introduce some concepts and notations used later on.
  In \Cref{sec:tri} we present the coinductive type families $\stream$ of streams and $\Tri$ of infinite triangular matrices and some operations on those
           codata types.
  In \Cref{sec:comonads} we present \emph{relative comonads} and define the category of comonads relative to a fixed functor.
    We give some examples of such structures, using the codata types presented in \Cref{sec:tri}.
  In \Cref{sec:comodules} we define comodules over relative comonads and give some constructions of comodules.
     Again, examples of such structures are taken from \Cref{sec:tri}.
  In \Cref{sec:coalgebras_for_tri} we define categories of coalgebras for the codata types presented in \Cref{sec:tri},
      based on the category-theoretic notions developped in the previous sections.
      We then prove that the codata types constitute the terminal coalgebras in the respective categories.
      Finally, we present an example of a map defined as a terminal map exploiting the universal property of streams.
   In \Cref{sec:formal} we explain some details of the formalization of this work in the proof assistant \coq.
  A table with the correspondence between formal and informal definitions is given in \Cref{sec:table_formal_informal}.
 

%  In this work we set off to characterize a specific \emph{co}inductive heterogeneous data type---the type family $\Tri$ of 
%  infinite triangular matrices as studied by \textcite{DBLP:conf/types/MatthesP11}, equipped with a \emph{co}substitution operation---as a terminal object of some 
%  category. For this, we start dualizing the approach by \textcite{DBLP:journals/iandc/HirschowitzM10}, where 
%  the crucial notions are the notion of monad and, more importantly, \emph{module over a monad}.
%  It turns out that more work than a simple dualization is necessary, for two reasons which we indicate in the following.
%  
  
  
  
  
\begin{comment}
 
 A first difference to the inductive case of the lambda calculus springs to mind:
 while the lambda calculus is essentially a monad---hence an \emph{endo}functor---on sets, the codata type $\Tri$ cannot be considered as such;
 for a given set $A$, the type $\Tri A$, equipped with its canonical \fat{bisimilarity} relation, 
 constitutes a \emph{setoid}---a set equipped with an equivalence relation---rather than a set.
 Instead of considering comonads---as the dual notion to monads---we thus have to consider a notion of comonad whose underlying functor is not necessarily endo.
 This is precisely the raison d'\^etre of \emph{relative} comonads (defined below)---the dual notion to the relative monads defined in 
  \parencite{DBLP:conf/fossacs/AltenkirchCU10}. 
 Fortunately, relative comonads have all the nice properties we could ask for; 
 in particular, the notion of module over a monad of \parencite{DBLP:journals/iandc/HirschowitzM10} extends to modules over \emph{relative} monads
 \parencite{ahrens_relmonads}, which can be dualized to obtain comodules over relative comonads.
 
 The other, more important difference between the inductive and the coinductive case stems from \emph{heterogeneity}:
 Two dual operations are responsible for the heterogeneity of the data type of lambda terms and the codata type of infinite triangular
 matrices: while we precompose with taking a \emph{co}product in the case of the abstraction of the lambda calculus---in order to account
 for context extension when passing under a binder---,
 we precompose with taking a \emph{product} when giving the target of the $\tail$ destructor of $\Tri$.
 However, as it turns out, the treatment of the $\tail$ destructor is far more complicated than a dualization of that of the abstraction 
 constructor of the lambda calculus---see \Cref{rem:shift} for a detailed explanation. 
 Describing our approach to a category-theoretic treatment of the $\tail$ destructor is the main purpose of the present work.
\end{comment} 
 
 
 

\section{Preliminaries}\label{sec:preliminaries}




The motivating examples we refer to throughout the paper are given by coinductive type families in Intensional Martin-L\"of type theory (IMLTT) \parencite{martin_lof}, 
a type-theoretic foundational system.
For $a,b : A$, we denote by $a = b$ the Martin-L\"of identity type between $a$ and $b$.



% \begin{definition}[Category]
%  A \emph{category} $\C$ in MLTT is given by a type $\C_0$ of objects, a dependent type of morphisms $\C(a,b)$ over objects $a,b : \C_0$, 
%  dependent functions for identity 
% \end{definition}
% 

\begin{definition}[Some categories]\label{def:set_setoid}
 We denote by $\Set$ the category of types (of a fixed universe) and total functions between them in Martin-L\"of type theory. 
 
 We denote by $\Setoid$ the category an object of which is a \emph{setoid}, i.e.\ a type equipped with an equivalence relation.
 A morphism between setoids is a type-theoretic function between the underlying types that is compatible in the obvious sense with the equivalence relations of the source and target setoids.
 If $A$ is a setoid, we also use $A$ to refer to its underlying type, and thus write $a:A$ for an element $a$ of the type underlying the setoid $A$. 
 We write $a\sim a'$ for related elements $a$ and $a'$ in $A$.
 We consider two parallel morphisms of setoids $f,g:A\to B$ equal if for any $a:A$ we have $fa \sim ga$.
\end{definition}

We also write $f:A\to B$ for a morphism $f$ between objects $A$ and $B$ in some category.


\begin{definition}\label{def:eq}
 The functor $\eq : \Set\to\Setoid$ is defined as the left adjoint to the forgetful functor $U : \Setoid \to \Set$.
  Explicitly, the functor $\eq$ sends any type $X$ to the setoid $(X,=_X)$ given by the type $X$ itself, equipped
  with the propositional equality relation $=_X$ specified via Martin-L\"of's identity type on $X$.
\end{definition}


\begin{remark}[Notation for product]
  We denote the category-theoretic binary product of objects $A$ and $B$ of a category $\C$ by $A\times B$.
  We write $\pr_1(A,B) : \C(A\times B, A)$ and $\pr_2(A,B) :\C(A\times B, B)$ for the projections, and we omit the 
  argument $(A,B)$ when it is clear from the context.
  Given $f : \C(A, B)$ and $g : \C(A,C)$, we write $\langle f,g\rangle : \C(A,B\times C)$ for the induced map into the product such that
  $\comp{\langle f,g\rangle}{\pr_1} = f$ and $\comp{\langle f,g\rangle}{\pr_2} = g$.
\end{remark}

Both of the categories of \Cref{def:set_setoid} have binary products; they are \emph{cartesian monoidal}, i.e.\ the terminal 
object is neutral with respect to the product. Functors preserving the monoidal structure up to isomorphism
are called \emph{strong monoidal}:

\begin{definition}[Strong monoidal functor]\label{def:monoidal_functor}
 A functor $F:\C\to\D$ between cartesian monoidal categories is \fat{strong monoidal} if, for any two objects $A$ and $B$ of $\C$,
  the morphism
 \[ \phi^F_{A,B} := \bigl\langle F(\pr_1), F(\pr_2) \bigr\rangle : \D\bigl(F(A\times B), FA\times FB\bigr)\enspace  \] 
 is an isomorphism.
 (Note that for \emph{cartesian} monoidal categories, the family $\phi$ of morphisms automatically 
  is compatible with the unitators and associators of the source and target categories, 
  since it is given by a universal property. 
  We shall not need strong monoidal functors between arbitrary monoidal categories.)
\end{definition}

\begin{example}
  The functor $\eq: \Set \to \Setoid$ of \Cref{def:eq} is strong monoidal.
\end{example}


\section{Some coinductive data types in Martin-L\"of type theory}\label{sec:tri}

In this section we present some coinductive type families which serve as examples in the later sections.
We also define \emph{bisimilarity} for each codata type, a coinductively defined equivalence relation which is considered 
as the appropriate notion of sameness on inhabitants of these types.
A coinductive type with bisimilarity hence forms a setoid as in \Cref{def:set_setoid}, 
we thus denote bisimilar elements using an infix $\sim$, as in $t \sim t'$. 

The first example is the type of \emph{streams} of elements of a given base type $A$. 
In the presentation we use the notational convention of \Cref{def:set_setoid}, using the same name for a setoid and its underlying type.
\begin{example}\label{ex_stream}
  Let $A$ by a type. The type $\stream(A)$ (or shorter $\stream A$) of \emph{streams over $A$} is coinductively defined via the following destructors:
  \begin{figure}[hbt]
  \begin{center}

     \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t : \stream A$}\doubleLine
     \UnaryInfC{$\shead_A~t : A$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t : \stream A$}\doubleLine
                                       \UnaryInfC{$\stail_A~t : \stream A$}
                                       \DisplayProof%

  \end{center}
\vspace{2ex}
  \begin{center}
                                            \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t \sim t'$}\doubleLine
     \UnaryInfC{$\shead~t = \shead~t'$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t \sim t'$}\doubleLine
                                       \UnaryInfC{$ \stail~t \sim \stail~t'$}
                                       \DisplayProof   
  \end{center}
  \caption{Destructors and bisimilarity for the coinductive type of streams} \label{fig:stream_destructors}
\end{figure}
    
   We define a cosubstition operation $\sredec_{A,B} : (\stream A \to B) \to \stream A\to\stream B$ on streams via the following clauses:
%    \begin{align} \shead\bigl(\sredec~f~t\bigr) &:= f~t \quad\text{ and } \notag\\
%                      \stail\bigl(\sredec~f~t\bigr) &:= \sredec~f~(\stail~t) \enspace . \label{eq:tail_sredec}
%     \end{align}
   \begin{align} \comp{\sredec~f}{\shead} := f \quad\text{ and } \notag\\
                  \comp{\sredec~f}{\stail} := \comp{\stail}{\sredec~f} \enspace . \label{eq:tail_sredec}
    \end{align}
\end{example}

% In the following, we denote by $\stream A$ the \emph{setoid} whose underlying type is the type of streams over $A$, equipped with the 
% equivalence relation of bisimilarity. By abuse of notation, we also refer to the underlying type by $\stream(A)$.


% TODO: image of stream


Streams are node-labelled trees where every node has exactly one subtree.
We also consider a type of trees where every node has an arbitrary, but fixed, number of subtrees, 
parametrized by a type $B$.

\begin{example}[Node-labelled trees]\label{ex_trees}
 We denote by $\Tree_B(A)$ the codata type given by one destructor $\shead$ and a family of 
 destructors $(\stail_b)_{b:B}$ with types analogous to those defining $\stream$ of \Cref{ex_stream}.
 We thus obtain $\stream$ by considering, for $B$, the singleton type.
\end{example}



A second example we consider is given by the codata type of
\emph{infinite triangular matrices}. It is more complicated than the example of streams as one of its destructors is \emph{heterogeneous},
as explained below.


\begin{example}\label{ex_tri}
This codata type is studied in detail by
 \textcite{DBLP:conf/types/MatthesP11}.
 We give a brief summary:
 
 
 The codata type family $\Tri$ of infinite triangular matrices 
 is parametrized by a fixed type $E$ for entries not on the diagonal, 
 and indexed by another, \emph{variable}, type $A$ for entries on 
 the diagonal. Schematically, such a matrix looks like in \Cref{fig_tri}.
 \begin{figure}[hbt]
 
 \begin{tikzpicture}[scale = 0.6]
    \foreach \y in {0,...,2}
    {\foreach \x in {\y,...,2}
      \draw (\x+1, -\y) node[color=blue]{$E$} ;
    }
    \foreach \x in {-1,...,3} \draw (\x, -\x-1) node[color=red]{$A$} ;
    \foreach \x in {0,...,3} \draw (\x, -\x)
    node[color=blue]{\textbf{$E$}} ;
    \draw(4,-2) node{$\ldots$};
    
    
      \draw[color=purple!70]  (2.4, -4.3) --node[auto, swap, left]{$\cut$}
     (-1.2,-0.6) -- (2.8,-0.6);
    \draw[color=purple!70, dashed]  (2.8,-0.6) -- (3.6,-0.6);
    \draw[color=purple!70, dashed]  (2.4,-4.3) -- (3.0,-5);

    \draw (-2,0) node{$\head$} ;
    
%      \draw[color=purple!70]  (2.8,-0.6) --  (0.1,-0.6) -- node[auto, swap,
%     left]{$\cut$}(0.8, -3.4);
    

%     \foreach \y in {0,...,2}
%     {\foreach \x in {\y,...,2}
%       \draw (1.5*\x+10.5, -\y) node[color=blue]{$E$} ;
%     }
%     \foreach \x in {0,...,3} \draw (1.5*\x+9, -\x)
%     node{{\color{blue}\textbf{E}} $\times$ {\color{red} A}} ;
%     \draw(14.5,-1.5) node{$\ldots$};
    
%     \draw[->] (5,-1.5) to node[swap, auto, above]{triangle}
%     (8,-1.5) ; 
    
%     \draw[<-] (5,-2.5) to node[swap, auto, below]{trapezium}
%     (8,-2.5) ; 

    \draw[color=green] (2.8,0.4) -- (-0.5,0.4) -- (-0.5, -1.1) --node[auto, swap, left]{$\tail$}
    (2.8,-4.5)  ; 
    \draw[color=green, dashed] (2.8,0.4) -- (3.6,0.4) ; 
    \draw[color=green, dashed] (2.8,-4.5) -- (3.5,-5.3) ; 

%     \draw[color=green] (13.5,0.4) -- (7.2,0.4) -- (13.5, -4); 
%     \draw[color=green, dashed] (13.5,0.4) -- (14.4,0.4) ; 
%     \draw[color=green, dashed] (13.5,-4) -- (14.3,-4.6) ; 

    \draw[color=orange](0, -0.5) ellipse (12pt and 25pt) ;  
    \draw[color=orange](1, -1.5) ellipse (12pt and 25pt) ;  
    \draw[color=orange](2, -2.5) ellipse (12pt and 25pt) ;  
    \draw[color=orange](3, -3.5) ellipse (12pt and 25pt) ;  
  \end{tikzpicture}\\[-2ex]

\begin{comment} 
 \begin{tikzpicture}[scale = 0.6]
     \foreach \y in {0,...,2}
     {\foreach \x in {\y,...,2}
       \draw (\x+1, -\y) node[color=blue]{$E$} ;
     }
     \foreach \x in {0,...,3} \draw (\x, -\x) node[color=red]{$A$} ;
     \draw(4,-1) node{$\ldots$};
%      \draw[style = dashed](0.5,0.2) -- (0.5,-1.2);
%      \draw[style = dashed](1.5,0.2) -- (1.5,-2.2);
%      \draw[style = dashed, thin](2.5,0.2) -- (2.5,-3.2);
     
%      \draw[color=green]  (3,0.5) -- (0.3,0.5) -- (0.3,
%      -1.2)  -- (2.8,-3.6);
%      \draw[color=green, dashed]  (3,0.5) -- (4,0.5);
%      \draw[color=green, dashed]  (2.8,-3.6) -- (3.5,-4.2);
 \end{tikzpicture}
\end{comment}
  \caption{An infinite triangular matrix over type $A$ and various operations}\label{fig_tri}
 \end{figure}
 
 It is specified via two destructors $\head$ and $\tail$, whose types are given in the first line of \Cref{fig:tri_destructors}.
 Bisimilarity on the inhabitants of that type is defined via the destructors of the second line of \Cref{fig:tri_destructors}.    
 As with streams, we denote by $\Tri A$ not only the resulting \emph{setoid} of triangular matrices over $A$, but also its
 underlying \emph{type}. 

\begin{figure}[hbt]
  \begin{center}

     \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t : \Tri~A$}\doubleLine
     \UnaryInfC{$\head_A~t : A$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t : \Tri~A$}\doubleLine
                                       \UnaryInfC{$\tail_A~t : \Tri(E\times A)$}
                                       \DisplayProof%

  \end{center}
\vspace{2ex}
  \begin{center}
                                            \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t \sim t'$}\doubleLine
     \UnaryInfC{$\head~t = \head~t'$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t \sim t'$}\doubleLine
                                       \UnaryInfC{$ \tail~t \sim \tail~t'$}
                                       \DisplayProof   
  \end{center}
  \caption{Destructors and bisimilarity for the coinductive family $\Tri$} \label{fig:tri_destructors}
\end{figure}


  An operation $\redec$ of type
    $ \redec_{A,B} : (\Tri A \to B) \to \Tri A \to \Tri B )$
  is defined  through the clauses
%     \begin{align}\head\bigl(\redec~f~t\bigr) &:= f~t \quad\text{ and } \notag\\
%                      \tail\bigl(\redec~f~t\bigr) &:= \redec\bigl(\extend~f\bigr)(\tail~t) \enspace . \label{eq:rest_redec}
%     \end{align}
    \begin{align} \comp{\redec~f}{\head} &:= f \quad\text{ and } \notag\\
                  \comp{\redec~f}{\tail} &:= \comp{\tail}{\redec~(\extend~f)} \enspace . \label{eq:rest_redec}
    \end{align}
Here, the family of functions 
     $\extend_{A,B} : (\Tri A \to B) \to \Tri (E \times A) \to E\times B $
  is suitably defined to account for the change of the type of the argument of $\redec$ when redecorating $\tail~t : \Tri(E\times A)$
  rather than $t : \Tri A$, namely
  \[ \extend(f) := \langle \comp{\head_{E\times A}}{\pr_1(E,A)} , \comp{\cut_A}{f} \rangle \enspace . \]
  The auxiliary function $\cut_A : \Tri(E\times A) \to \Tri A$ is defined corecursively via
%    \begin{align*} \head\bigl(\cut~t\bigr) := \pr_2(\head~t) \quad\text{ and } \quad
%                      \tail\bigl(\cut~t\bigr) := \cut(\tail~t) \enspace . 
%       \end{align*}
      \begin{align*} \comp{\cut}{\head} := \comp{\head}{\pr_2} \quad\text{ and } \quad
                     \comp{\cut}{\tail} := \comp{\tail}{\cut} \enspace . 
      \end{align*}
%       
All the operations are suitably compatible with the bisimilarity relations, so that they can be equipped with the types
  \begin{align*}
    \redec_{A,B} &: \Setoid(\Tri A,\eq B) \to \Setoid(\Tri A,\Tri B ) \\
    \extend_{A,B} &: \Setoid(\Tri A,\eq B) \to \Setoid\bigr(\Tri (E \times A),\eq(E\times B)\bigr) \\
    \cut_A &:  \Setoid(\Tri(E\times A) , \Tri A) \enspace .
  \end{align*}
\end{example}

Note how heterogeneity of the destructor $\tail$ makes the definition of $\redec$ considerably more complicated than that of
the analogous operation $\sredec$ on streams.

\begin{comment}  
  The $\cobind$ operation---called \emph{redecoration} or $\redec$ in \parencite{DBLP:conf/types/MatthesP11}--- of type
   \[ \redec_{A,B} : \Setoid(\Tri A,\eq B) \to \Setoid(\Tri A,\Tri B )\] is defined 
  corecursively, for $f:\Setoid(\Tri A,\eq B)$  and $t : \Tri A$ by
      \begin{align}\head\bigl(\redec~f~t\bigr) &:= f~t \quad\text{ and } \notag\\
                     \tail\bigl(\redec~f~t\bigr) &:= \redec\bigl(\extend~f\bigr)(\tail~t) \enspace . \label{eq:rest_redec}
      \end{align}
Here, the family of functions 
     \[\extend_{A,B} : \Setoid(\Tri A,\eq B) \to \Setoid\bigr(\Tri (E \times A),\eq(E\times B)\bigr)\]
  is suitably defined to account for the change of the type of the argument of $\redec$ when redecorating $\tail~t : \Tri(E\times A)$
  rather than $t : \Tri A$, namely
  \[ \extend(f) := \langle \comp{\head_{E\times A}}{\pr_1(E,A)} , \comp{\cut_A}{f} \rangle \enspace . \]
  The auxiliary function $\cut_A : \Tri(E\times A) \to \Tri A$ is defined corecursively via
   \begin{align*}\head\bigl(\cut~t\bigr) &:= \pr_2(\head~t) \quad\text{ and } \\
                     \tail\bigl(\cut~t\bigr) &:= \cut(\tail~t) \enspace . 
      \end{align*}
  More precisely, the function $\cut$ constitutes a family of morphisms of setoids \[\cut_A : \Setoid(\Tri(E\times A),\Tri A) \enspace ,\]
  but for the sake of readability, we will leave this compatibility implicit in the following and simply write $\Tri A \to \Tri B$
  instead of $\Setoid(\Tri A,\Tri B)$.
\end{comment}
  
  
%  Note that what is called $\extend$ here is called \textit{lift} in \parencite{DBLP:conf/types/MatthesP11}.
% \end{example}

% TODO: should this comment go away?
% \begin{remark}\label{rem:wrong_cut}
% In the definition of the $\extend$ operation in \Cref{ex:tri_comonad} the auxiliary operation $\cut$ plays a central r\^ole.
% It should be remarked here that, using functoriality of $\Tri$, one can define another operation of the same type, namely the family of 
% maps $\Tri(\pr_2(E,A)) : \Tri(E\times A) \to \Tri A$ for
% all sets $A$. Had we used this operation rather than the corecursively defined $\cut$ of \Cref{ex:tri_comonad}, 
% then the third comonad law would have failed; we refer to \parencite{DBLP:conf/types/MatthesS07} for details.
% \end{remark}





\section{Relative comonads and their morphisms}\label{sec:comonads}

In this section we define the category of \emph{comonads relative to a fixed functor}, and present some examples 
of such comonads and their morphisms.

\emph{Relative monads} were defined by \textcite{DBLP:conf/fossacs/AltenkirchCU10} as a notion of monad-like structure
whose underlying functor is not necessarily an endofunctor.
The dual notion is that of a relative \emph{co}monad:

\begin{definition}[Relative comonad]\label{def:rel_comonad}
  Let $F:\C\to\D$ be a functor. A \fat{relative comonad $T$ over $F$} is given by
  \begin{packitem}
   \item a map $T:\C_0 \to \D_0$ on the objects of the categories involved;
   \item an operation $\counit : \forall A : \C_0, \D(TA,FA)$;
   \item an operation $\cobind: \forall A,B:\C_0, \D(TA,FB) \to \D(TA,TB)$
  \end{packitem}
  such that 
  \begin{packitem}
   \item $\forall A,B:\C_0, \forall f:\D(TA,FB), \comp{\cobind(f)}{\counit_B} = f$;
   \item $\forall A : \C_0, \cobind(\counit_A) = \id_{TA}$;
   \item $\forall A,B,C:\C_0, \forall f : \D(TA,FB),\forall g:\D(TB,FC), \\
        \comp{\cobind(f)}{\cobind(g)} = \cobind(\comp{\cobind(f)}{g})$.
  \end{packitem} 
\end{definition}
Just like relative monads, relative comonads are functorial:
\begin{definition}[Functoriality for relative comonads]\label{def:lift}
 Let $T$ be a  comonad relative to $F:\C\to\D$.
 For $f : \C(A,B)$ we define
  \[ \lift^T(f) := \cobind(\comp{\counit_A}{Ff}) \enspace .  \]
 The functor properties are easily checked.
\end{definition}
Relative comonads over the identity functor are exactly comonads.


\begin{example}[Relative comonads from comonads]\label{ex_relcom_from_com}
  Let $F : \C \to \D$ be a fully faithful functor and $(M,\counit,\cobind)$ be a (traditional) comonad (in Kleisli form) on $\C$.
  We define a comonad $FM$ relative to $F$ by setting:
  \begin{itemize}
   \item $FM(A) := F(MA)$;
   \item $\counit^{FM}_A := F(\counit^M_A) : \D(FMA,FA)$;
   \item $\cobind^{FM}_{A,B} (f) := F\bigl(\cobind^M_{A,B}(F^{-1}f)\bigr)$.
  \end{itemize}
  The proof of the axioms of a relative comonad is immediate.
\end{example}



\begin{example}[Streams]\label{ex_stream_comonad}
  The codata type family $\stream : \Set \to \Setoid$ of \Cref{ex_stream} is equipped with a structure of a comonad relative to the functor 
  $\eq : \Set \to \Setoid$ via the following operations:
  \begin{itemize}
   \item $\counit_A := \shead_A$
   \item $\cobind_{A,B} := \sredec_{A,B}$ 
  \end{itemize}
  We refrain from showing the proof of the comonadic laws here; it can be found in our \coq library.  
\end{example}

\begin{example}[Trees]\label{ex_tree_comonad}
 Fix a type $B$. Analogously to \Cref{ex_stream_comonad}, the map $A \mapsto \Tree_B(A)$ of \Cref{ex_trees}
 is equipped with a structure of a comonad relative to $\eq: \Set\to\Setoid$.
\end{example}


\begin{example}[Infinite triangular matrices]\label{ex:tri_comonad}
 
  The codata type family $\Tri : \Set \to \Setoid$ of \Cref{ex_tri} is equipped with a structure of a comonad relative to the functor 
  $\eq : \Set \to \Setoid$ via the following operations:
  \begin{itemize}
   \item $\counit_A := \head_A$
   \item $\cobind_{A,B} := \redec_{A,B}$ 
  \end{itemize}
 Again, the example is completely done in our \coq library.
\end{example}

\begin{remark}
 \textcite{DBLP:conf/types/MatthesP11} define a notion of \emph{weak constructive comonad}, and show that the data type $\Tri$
  is an instance of such a comonad. 
  Such a weak constructive comonad, however, is \emph{precisely}
  a comonad relative to the functor $\eq : \Set\to\Setoid$.
\end{remark}


The notion of relative comonad captures many properties of $\stream$ and $\Tri$ and their respective operations, in particular the interplay
of cosubstitution/redecoration with the destructors $\shead$ and $\head$ via the first two comonad laws.
Much of the rest of the present work is concerned with finding a suitable categorical notion that captures the interplay 
of redecoration with the other destructors, $\stail$ and $\tail$, respectively. 
This is the purpose of the notion of \emph{comodule over relative comonad} introduced in \Cref{sec:comodules}.




\emph{Morphisms of relative comonads} are natural transformations that are compatible with the comonadic structure:

\begin{definition}[Morphism of relative comonads]\label{def:comonad_morphism}
 Let $T$ and $S$ be comonads relative to a functor $F : \C \to \D$. A \fat{morphism of relative comonads} $\tau : T \to S$
  is given by a family of morphisms \[\tau_A : \D(TA,SA)\] such that for any $A : \C_0$,
     \[  \counit^T_A = \comp{\tau_A}{\counit^S_A} \]
   and for any $A,B : \C_0$ and $f : \D(SA,FB)$,
   \[  \comp{\cobind^T(\comp{\tau_A}{f})}{\tau_B} = \comp{\tau_A}{\cobind^S(f)} \enspace .  \]
\end{definition}

Relative comonads over a fixed functor $F$ and their morphisms form a category $\RComonad(F)$.

\begin{remark}
A morphism $\tau : T\to S$ of relative comonads over a functor $F:\C\to\D$ is  \emph{natural}
with respect to the functorial action of \Cref{def:lift}.
\end{remark}

\begin{example}\label{ex_relcom_from_com_morphism}
 Continuing \Cref{ex_relcom_from_com} with $M, M'$ two monads on $\C$, given a comonad morphism $\tau : M \to M'$, one obtains a morphism of 
 relative comonads $F\tau : FM\to FM'$ by setting $F\tau_A := F(\tau_A)$.
 Again, the axioms are easy to check.
\end{example}

\begin{remark}
 The definitions given in \Cref{ex_relcom_from_com} and \Cref{ex_relcom_from_com_morphism} yield a functor from 
 comonads on $\C$ to comonads relative to $F:\C\to\D$. 
 If $F$ is a right adjoint with left adjoint $L$, $L\dashv F$, then postcomposing a comonad $T$ relative to $F$ with $L$
 yields a monad on $\C$. Again, this map extends to comonad morphisms.
 The two functors thus defined are again adjoints.
 Writing down the details is lengthy but easy.
\end{remark}



\begin{example}\label{ex_diag}

We define $\diagonal_A : \Tri A \to \stream A$ via the following clauses:
    \begin{align}\shead~(\diagonal_A~t) &:= \head~t \quad\text{ and } \notag\\
                     \stail\bigl(\diagonal_A~t\bigr) &:= \diagonal_A (\cut (\tail~t)) \enspace . \label{eq:diag}
    \end{align}
 This defines a morphism of relative comonads $\diagonal : \Tri \to \stream$.
\end{example}

\begin{example}
%  TODO: can we define a kind of inverse to diag
\end{example}



\begin{remark}
 The destructors $\stail$ (for $\stream$) and $\tail$ (for $\Tri$) are \emph{not} comonad morphisms.
 One can, however, equip the functor given by precomposing $\Tri$ with \enquote{product with $E$}, i.e.\
 $A \mapsto \Tri (E\times A)$, with a structure of relative comonad, induced by that
 on $\Tri$, cf.\ \Cref{product_comonad}.
\end{remark}




\begin{definition}\label{product_comonad}
  Let $T$ be a comonad relative to a strong monoidal functor $F:\C\to\D$ between cartesian monoidal categories,
  and let $E:\C_0$ be a fixed object of $\C$.
 The map $A\mapsto T(E\times A)$ inherits the structure of a comonad relative to $F$ from $T$: the 
 counit is defined as
   \[ \counit_A := \comp{\lift^T(\pr_2(E,A))}{\counit^T_{A}} \]
  and the cobind operation as
   \begin{align*} 
            \cobind_{A,B} : \D\bigl(T(E\times A),FB\bigr) &\to \D\bigl(T(E\times A),T(E\times B)\bigr) \\
              f &\mapsto  \cobind^T(\extend'~f)
   \end{align*}
  with $\extend'$ defined as 
  \begin{align*} \extend' : \D\bigl(T(E\times A),FB\bigr) &\to \D\bigl(T(E\times A), F(E\times B)\bigr) \enspace , \\ 
                                            f & \mapsto \comp{\langle \comp{T(\pr_1)}{\counit^T_E}, f \rangle}{{\phi^{F}_{E,B}}^{-1}} \enspace .
  \end{align*}
\end{definition}


Constructors of inductive types are characterised by \textcite{DBLP:journals/iandc/HirschowitzM10} via the notion of
\emph{module over a monad}. We  dualize their approach by introducing comodules over (relative) comonads.



\section{Comodules over relative comonads}\label{sec:comodules}

In this section we dualize the notion of module over a relative monad as developed in earlier work \parencite{ahrens_relmonads}.

\begin{definition}[Comodule over relative comonad]\label{def:comodule}
 Let $T$ be a relative comonad over the functor $F:\C\to\D$, and let $\E$ be a category.
 A \fat{comodule over T towards $\E$} consists of
   \begin{packitem}
   \item a map $M:\C_0 \to \E_0$ on the objects of the categories involved;
   \item an operation $\mcobind: \forall A,B:\C_0, \D(TA,FB) \to \E(MA,MB)$
  \end{packitem}
  such that 
  \begin{packitem}
   \item $\forall A : \C_0, \mcobind(\counit_A) = \id_{MA}$;
   \item $\forall A,B,C:\C_0, \forall f : \D(TA,FB),\forall g:\D(TB,FC), \\
        \comp{\mcobind(f)}{\mcobind(g)} = \mcobind(\comp{\cobind(f)}{g})$ .
  \end{packitem}

\end{definition}




Every relative comonad comes with a canonical comodule over it, the \emph{tautological comodule}:

\begin{definition}[Tautological comodule]\label{def:tautological_comodule}
  Given a comonad $T$ relative to $F:\C\to\D$, the assignment $A \mapsto TA$ yields a comodule over $T$ 
  with target category $\D$, the \textbf{tautological comodule} of $T$, also called $T$.
  The comodule operation is given by
    \[  \mcobind^T(f) := \cobind^T(f) \enspace . \]
\end{definition}


A more interesting example of comodule is given by the functor that maps a type $A$ to the setoid $\Tri(E\times A)$:
\begin{example}\label{ex_tri_prod_comod}
   The map $A \mapsto \Tri(E\times A)$ is equipped with a comodule structure over the relative comonad $\Tri$ by
   defining the comodule operation $\mcobind$ as
     \[ \mcobind_{A,B} (f) := \redec (\extend~f) \enspace , \]
  using the operations defined in \Cref{ex_tri}.
\end{example}



A \emph{morphism of comodules} is given by a family of morphisms that is compatible with 
the comodule operation:

\begin{definition}[Morphism of comodules]\label{def:morphism_of_comodules}
 Let $M, N : \C \to \E$ be comodules over the comonad $T$ relative to  $F:\C \to \D$.
 A \fat{morphism of comodules} from $M$ to $N$ is given by a family of morphisms 
   \[ \alpha_A:\E(MA,NA) \]
 such that for any $A,B:\C_0$ and $f : \D(TA,FB)$ one has
 \[   \comp{\mcobind^M(f)}{\alpha_B} = \comp{\alpha_A}{\mcobind^N(f)} \enspace . \]
\end{definition}

 \begin{example}
  The destructor $\stail_A : \stream A \to \stream A$ is the carrier of a morphism of tautological comodules.
 \end{example}

\begin{example}[$\tail$ is a comodule morphism]\label{ex:tail_comodule}
 The destructor $\tail$ of \Cref{ex_tri} is a morphism of comodules over the comonad $\Tri$ 
  from the tautological comodule  $\Tri$ to $\Tri(E\times \_)$ (cf.\ \Cref{ex_tri_prod_comod}).
\end{example}

Composition and identity of comodule morphisms happens pointwise. We thus obtain a category of comodules
over a fixed comonad, towards a fixed target category:

\begin{remark}[Category of comodules]
 Fix a comonad $T$ relative to $F:\C\to\D$ and a category $\E$.
 Comodules over $T$ towards $\E$ and their morphisms  form a category $\RComod(T,\E)$.
\end{remark}

Similarly to relative comonads, comodules over these are functorial:

\begin{definition}[Functoriality for comodules]\label{def:comodule_lift}
 Let $M : \RComod(T,\E)$ be a comodule over $T$ towards some category $\E$. For $f : \C(A,B)$ we define
  \[ \mlift^M(f) := \mcobind(\comp{\counit_A}{Ff}) .  \]
\end{definition}


\begin{remark}
  The family of morphisms constituting a comodule morphism is actually natural with respect to the functoriality 
  defined in \Cref{def:comodule_lift}.
\end{remark}

Given a morphism of comonads, we can \enquote{transport} comodules over the source comonad to comodules over the target comonad:


\begin{definition}[Pushforward comodule]\label{def:pushforward_comodule} % checked
  Let $\tau : T\to S$ be a morphism of comonads relative to a functor $F : \C \to \D$, and let furthermore $M$ be a 
  comodule over $T$ towards a category $\E$. We define the \fat{pushforward comodule} $\tau_*M$ to be the comodule over $S$ given by
  \[  \tau_*M(A) := MA \]
  and, for $f : \D(SA,FB)$,
   \[ \mcobind^{\tau_*M}(f) := \mcobind^M(\comp{\tau_A}{f}) \enspace . \]
   
  \noindent
  Pushforward is functorial: if $M$ and $N$ are comodules over $T$ with codomain category $\E$, and $\alpha : M\to N$ is 
    a morphism of comodules, then we define \[\tau_*\alpha : \tau_*M \to \tau_*N\] 
    as the family of morphisms
     \[ (\tau_*\alpha)_A := \alpha_A \enspace . \]
  It is easy to check that this is a morphism of comodules (over $S$) between $\tau_*M$ and $\tau_*N$.
  Pushforward thus yields a functor $\tau_*:\RComod(T,\E) \to \RComod(S,\E)$.
\end{definition}


Every (relative) comonad induces a comodule over itself, the tautological comodule (\Cref{def:tautological_comodule}).
Furthermore, every morphism of relative comonads induces a morphism of comodules:

\begin{definition}[Morphism of comonads induces morphism of comodules]\label{def:induced} % checked
  Let $\tau : T\to S$ be a morphism of comonads relative to a functor $F : \C \to \D$.
  Then $\tau$ gives rise to a morphism of comodules over $S$ from the pushforward of the tautological comodule
  of $T$ along $\tau$ to the tautological comodule over $S$,
  \[ \induced{\tau} : \tau_*T \to S \enspace , \quad \induced{\tau}_A := \tau_A \enspace . \]
\end{definition}




\section{Terminality for streams and infinite triangular matrices}\label{sec:coalgebras_for_tri}



As an application of comodules over relative comonads, we use that notion to
 define \fat{coalgebras} for the signatures of the example data types we have studied so far.
 We then show that the codata types specified by the corresponding signatures constitute the respective \emph{terminal}
 such coalgebra.
 While this result is hardly surprising, it is still interesting as it characterises not only the codata types themselves,
 but also the respective bisimilarity relations on them as well as the cosubstitution operations, via a universal property.
 
\subsection{Coalgebras for $\stream$}


We first consider the homogeneous codata type of streams.



\begin{definition}[Coalgebras for $\stream$]\label{cat_stream}
  We define a \fat{coalgebra for $\stream$} to be given by 
  \begin{itemize}
   \item a comonad $S$ relative to $\eq : \Set \to \Setoid$ and
   \item a morphism $t$ of tautological comodules over $S$, $t : S \to S$.
  \end{itemize}
  A coalgebra morphism $(S,t) \to (S',t')$ is given by a comonad morphism $\tau : S \to S'$ such that
     \[ \comp{\tau_*t}{\induced{\tau}} = \comp{\induced{\tau}}{t'} \enspace . \]
\end{definition}

This defines a category, with the obvious composition and identity. 

\begin{theorem}\label{thm_stream_terminal}
 The pair $(\stream, \stail)$ is the terminal coalgebra in the category of coalgebras of \Cref{cat_stream}.
\end{theorem}

\begin{example}
  We equip the relative comonad $\Tri$ with the structure of a coalgebra for $\stream$ by defining the following 
  morphism of tautological comodules over $\Tri$:
   \[ t^{\diagonal} := \comp{\tail}{\cut}  : \Tri \to \Tri \enspace . \] 
  This defines a coalgebra $(\Tri, t^{\diagonal})$ and the resulting terminal coalgebra morphism
   $(\Tri, t^{\diagonal}) \to (\stream, \stail)$ is the one defined in \Cref{ex_diag}.
\end{example}


\begin{remark}
 Fix a type $B$. A result analogous to \Cref{thm_stream_terminal} holds for trees $\Tree_B$ of \Cref{ex_tree_comonad}. 
 We refrain from giving a precise statement of this result.
\end{remark}




\subsection{Coalgebras for $\Tri$}

In analogy to the definition of coalgebras for the signature of streams (\Cref{cat_stream}), one would define
a coalgebra for the signature of $\Tri$ as a pair $(T,r)$ of a comonad $T$ relative to $\eq : \Set \to \Setoid$ and 
a morphism of comodules $r : T \to T(E\times \_)$. 
It turns out that in this way, one is not capable of obtaining the right auxiliary function $\cut$ for what is
supposed to be the \emph{terminal} such coalgebra, namely the pair $(\Tri,\tail)$.
As a remedy, we define a coalgebra to come equipped with a specified operation analogous to $\cut$, and some laws governing
the behaviour of that operation:


\begin{comment}
\begin{remark}[$\shift$ operation for the lambda calculus]\label{rem:shift}
  The heterogeneous data type of lambda terms comes with a term constructor $\abs_A : \ULC (A^*) \to \ULC A$, which 
  is the constructor responsible for the heterogeneity of that data type.
  We compare the $\extend$ operation to the one with analogue purpose in the case of the lambda calculus,
  the $\shift$ operation, of type
  \begin{equation}  \shift_{A,B} : \Set(A,\ULC B) \to \Set\bigl(A^*,\ULC(B^*)\bigr) \enspace .\label{eq:shift}\end{equation}
  Here $\ULC A$ denotes the set of lambda terms in context $A$, and $A^*:=1 + A$ denotes the context $A$ extended by a distinguished 
  variable---the variable bound by the abstraction constructor.
  
  The $\shift$ operation is used in the definition of the monadic substitution operation
  \[ \subst_{A,B} : \Set(A,\ULC B) \to \Set(\ULC A,\ULC B) \]
  of the lambda calculus, when recursively substituting under an abstraction:
   \[ \subst~f~(\abs~t):= \abs\bigl(\subst~(\shift~f)~t\bigr) \enspace . \]
  The reader is encouraged to compare this equation to \Cref{eq:rest_redec}.
  
  The $\shift$ operation can be defined in monadic terms, for any monad $T$ on the category of sets such that,
  when $T$ is instantiated by the monad $\ULC$, it becomes the specific $\shift$ operation of \Cref{eq:shift}.
  
  However, we were \emph{not} able to express the $\extend$ operation of $\Tri$ entirely in terms of categorical and comonadic operations. Indeed, if
  one dualizes the categorical definition of $\shift$, one obtains an operation that has the same type as $\extend$, 
  but for which, when used to define the redecoration, some comonadic property of redecoration fails.
  More specifically, it is the auxiliary $\cut$ operation as defined in \Cref{ex:tri_comonad} which does not seem to be 
  definable in categorical terms. There is an operation of the same type which is categorical---see \Cref{canonical_cut}---but
  which does not yield a comonadic redecoration operation (cf.\ \Cref{rem:wrong_cut}).
\end{remark}


The failure to describe the $\extend$ operation---more precisely, the auxiliary $\cut$---in categorical terms leads us 
to considering comonads that come with a specified $\cut$ operation for some fixed object $E$ in the source category:
\end{comment}



\begin{definition}[Relative comonad with cut]\label{def:rel_comonad_with_cut}
 Let $\C$ and $\D$ be categories with binary products and $F:\C\to\D$ a strong monoidal functor. Let $E:\C_0$ be a fixed object of $\C$.
 We define a \fat{comonad relative to $F$ with cut relative to $E$} to be a comonad $T$ relative to $F$ together with a $\cut$ operation 
    \[ \cut : \forall~A:\C_0, T(E\times A) \to TA \]
 satisfying the following axioms:
  \begin{itemize}
%    \item $\forall~A:C_0, \comp{\cut_A}{\counit_A} = \comp{\counit_{E\times A}}{F(\pr_2(E,A))}$;
   \item $\forall~A:C_0, \comp{\cut_A}{\counit_A} = \comp{\lift^T(\pr_2(E,A))}{\counit_{A}}$;
   \item $\forall~A~B:C_0,\forall~f:\D(TA,FB), \comp{\cut_A}{\cobind(f)} = \comp{\cobind(\extend~f)}{\cut_B}$,
  \end{itemize}

  \noindent
  where, for $f:\D(TA,FB)$, we define $\extend(f) : \D\bigl(T(E\times A),F(E\times B)\bigr)$ as
       \[ \extend(f) := \comp{\comp{\langle T(\pr_1) , \cut \rangle}{(\counit_E\times f)}}{{\phi^{F}_{E,B}}^{-1}} \enspace . \]
  
\end{definition}

Morphisms of comonads with cut are morphisms of comonads that are compatible with the respective $\cut$ operations:

\begin{definition}[Morphism of comonads with cut]\label{def:morphism_comonad_cut}
 Let $(T,\cut^T)$ and $(S,\cut^S)$ be two comonads relative to a functor $F$ with cut relative to $E$ as in \Cref{def:rel_comonad_with_cut}.
 A \emph{morphism of comonads with cut} is a comonad morphism $\tau$ between the underlying comonads as in \Cref{def:comonad_morphism} that 
 commutes suitably with the respective $\cut$ operations, i.e.\ for any $A : \C_0$,
  \[ \comp{\tau_{E \times A}}{\cut^S_A}  = \comp{\cut^T_A}{\tau_A} \enspace . \]
\end{definition}


Comonads with cut relative to a fixed functor $F:\C\to\D$ and $E:\C_0$ form a category $\RComonadWC(F,E)$.
There is the obvious forgetful functor from $\RComonadWC(F,E)$ to $\RComonad(F)$.
Conversely, any comonad $T$ relative to a suitable functor can be equipped with a $\cut$ operation, using functoriality of $T$:



\begin{remark}[Canonical $\cut$ operation]\label{canonical_cut}
 Any comonad $T$ relative to a strong monoidal functor $F:\C\to\D$  can be equipped with a $\cut$ operation relative to 
 $E:\C_0$ satisfying the properties of \Cref{def:rel_comonad_with_cut} by setting
   \[ \ccut_A := \cut_A := \lift^T\bigl(\pr_2(E,A)\bigr) \enspace . \]
 (The extra \enquote{c} of $\ccut$ stands for \enquote{canonical}.)
 It follows from the axioms of comonad morphism that a comonad morphism $\tau : T\to S$ satisfies the equation of \Cref{def:morphism_comonad_cut} 
 for the thus defined operations $\ccut^T$ and $\ccut^S$, hence constitutes a morphism of comonads with cut from $(T,\ccut^T)$ to $(S,\ccut^S)$.
 We thus obtain a functor 
 \[ \ccut_{F,E} : \RComonad(F) \to \RComonadWC(F,E)\]
 from relative comonads over $F$ to relative comonads over $F$ with cut relative to a fixed object $E:\C_0$ given on 
 objects by $T\mapsto (T,\ccut^T)$.
\end{remark}

The functor $\ccut_{F,E}$, followed by the forgetful functor, yields the identity. We can thus view
relative comonads with cut as a generalization of relative comonads.


Our prime example of relative comonad comes with a $\cut$ operation that is \emph{not} the canonical one:

\begin{example}[$\cut$ for $\Tri$]\label{def:cut_for_tri}
  The relative comonad $\Tri$ from \Cref{ex:tri_comonad}, together with the $\cut$ operation defined in \Cref{ex_tri}, 
  is a comonad with cut as in \Cref{def:rel_comonad_with_cut}.
\end{example}





Given a comodule $M$ over a relative comonad with cut, we define a comodule over the same comonad obtained by precomposition of $M$ with
\enquote{product with a fixed object $E$}:


\begin{definition}[Precomposition with product]\label{def:product_in_context}
 Suppose $F:\C\to\D$ is a strong monoidal functor, and $T$ is a comonad relative to $F$ with a $\cut$ operation 
 relative to $E:\C_0$ as in \Cref{def:rel_comonad_with_cut}.
 Given a comodule $M$ over $T$,  precomposition with \enquote{product with $E$}
 gives a comodule $M(E\times\_)$ over $T$,
  \[    M(E\times \_) : A \mapsto M(E\times A) \enspace . \]
 The comodule operation is deduced from that of $M$ by 
 \begin{align*} \mcobind^{M(E\times\_)}_{A,B} : \D(TA,FB)&\to \E\bigl(M(E\times A), M(E\times B)\bigr) \enspace ,\\
                                                      f &\mapsto \mcobind^M_{E\times A,E\times B}(\extend(f)) \enspace ,
  \end{align*}                                        
where the $\extend$ operation is the one defined in \Cref{def:rel_comonad_with_cut}.
 
 Furthermore, given two comodules $M$ and $N$ over $\T$ with target category $\E$, and a comodule morphism $\alpha : M \to N$,  
 we can define a comodule morphism \[\alpha(E\times \_) : M(E\times \_) \to N(E\times \_) \] by setting
          \[ \alpha(E \times \_)_A := \alpha_{E\times A} \enspace . \]
  
  \noindent
  We thus obtain an endofunctor on the category of comodules over $T$ towards $\E$,
   \[ M \mapsto  M (E\times \_) : \RComod(T,\E) \to \RComod(T,\E) \enspace . \]
\end{definition}


Before we give an example---really, the reason we did all this work---using such a comodule, we state some more facts about 
the construction just described:

\begin{remark}[Pushforward commutes with product in context]\label{rem:prod_pullback_commute}
 Note that the constructions of \Cref{def:product_in_context} and \Cref{def:pushforward_comodule} commute in the sense that
 we have an isomorphism of comodules \[\tau_*(M(E\times \_)) \cong (\tau_*M)(E \times \_)  \]
 given pointwise by identity morphisms.
\end{remark}



It directly follows from the definition that the cut operation of any comonad $T$ with cut 
constitutes a comodule morphism $\cut : T(E\times \_) \to T$.
We can thus restate the definition of a morphism of comonads with cut as in \Cref{def:morphism_comonad_cut} by asking the following diagram 
of comodule morphisms (in the category $\RComod(S,\D)$) to commute
(where in the upper left corner we silently add an isomorphism as in \Cref{rem:prod_pullback_commute}):
 \[ \begin{xy}
       \xymatrix{  **[l] \tau_*T(E\times \_ )  \ar[r]^{\tau_*(\cut^T)} \ar[d]_{\induced{\tau}(E\times \_)}  &  **[r] \tau_*T \ar[d]^{\induced{\tau}} \\
                   **[l]  S (E\times \_ ) \ar[r]_{\cut^S}  &  **[r] S  \enspace .
        }
      \end{xy}
   \]


The construction of \Cref{def:product_in_context} yields a categorical characterization of the $\tail$ destructor---%
more precisely, of \Cref{eq:rest_redec}, via the notion of comodule morphism:

% TODO: we already have that example
\begin{example}[$\tail$ is a comodule morphism]\label{ex:tail_comodule}
 Consider the comonad $\Tri$, equipped with the $\cut$ operation of \Cref{def:cut_for_tri}.
 The destructor $\tail$ of \Cref{ex_tri} is a morphism of comodules over the comonad $\Tri$ 
  from the tautological comodule  $\Tri$ to $\Tri(E\times \_)$.
\end{example}








We now define a category in which the codata type of triangular matrices, equipped with the bisimilarity relation of \Cref{ex_tri}
and the comonadic redecoration, constitutes the terminal object. We call an object of this category a \emph{coalgebra of triangular matrices}, 
even though we do not define the category as a category of coalgebras of a given endofunctor.

The definition of such a coalgebra is obtained by collecting all the information we have gathered so
far about the comonad $\Tri$, and abstracting from this particular comonad:


\begin{definition}[Coalgebras of infinite triangular matrices]\label{def:cat_tri}
   Let $E:\Set_0$ be a set.
   Let $\mathcal{T} = \mathcal{T}_E$ be the category where an object consists of
   \begin{itemize}
    \item a comonad $T$ over the functor $\eq:\Set\to\Setoid$ with $\cut$ relative to $E$ and
    \item a morphism $\tail$ of comodules over $T$ of type $T \to T(E\times \_)$
   \end{itemize}
   such that for any set $A$,
    \[ \comp{\cut_A}{\tail_A} = \comp{\tail_{E\times A}}{\cut_{E\times A}} \enspace . \]
   The last equation can be stated as an equality of comodule morphisms as
     \[ \comp{\cut}{\tail} = \comp{\tail(E\times \_)}{\cut(E\times\_)} \quad \bigl( = (\comp{\tail}{\cut})(E\times \_)\bigr)\enspace . \]

  
   
   A morphism between two such objects $(T,\tail^T)$ and $(S,\tail^S)$
   is given by a morphism of relative comonads with cut $\tau : T \to S$ such that
   the following diagram of comodule morphisms in the category $\RComod(S,\E)$ commutes,
   
   \[ \begin{xy}
       \xymatrix{   \tau_*T  \ar[r]^{\tau_*(\tail^T)} \ar[d]_{\induced{\tau}}  &  **[r] \tau_*T (E\times \_ )\ar[d]^{\induced{\tau}(E\times \_)} \\
                    S  \ar[r]_{\tail^S}  &  **[r] S (E\times \_ ) \enspace .
        }
      \end{xy}
   \]

   \noindent
   Here in the upper right corner we silently insert an isomorphism as in \Cref{rem:prod_pullback_commute}.
\end{definition}   
   

\begin{theorem}\label{ex:final_sem_tri} % checked   
   The pair $(\Tri, \tail)$ consisting of the relative comonad with cut $\Tri$ of \Cref{def:cut_for_tri} together with 
    the morphism of comodules $\tail$ of \Cref{ex:tail_comodule},
   constitutes the terminal coalgebra of triangular matrices.
\end{theorem}

\begin{proof}[Proof sketch]
   For a given coalgebra $(T,\tail^T)$, the (terminal) morphism $\bigcirc = \bigcirc_T:T\to\Tri$ is defined via the corecursive equations
    \begin{align}\head\bigl(\bigcirc~t\bigr) &:= \counit^T~t \quad\text{ and } \label{eq:terminal_top}\\
                     \tail\bigl(\bigcirc~t\bigr) &:= \bigcirc(\tail^T~t) \enspace . \label{eq:terminal_rest}
      \end{align}
      By coinduction we show that the map $\bigcirc$ is compatible with $\cobind$ and $\cut$ operations of the source and 
   target coalgebras. We omit these calculations, which can be consulted in the \coq source files.
   
   Note that there is actually no choice in this definition: \Cref{eq:terminal_top} is forced upon us since we want $\bigcirc$ to constitute 
   a morphism of comonads---the equation directly corresponds to one of the axioms.
   \Cref{eq:terminal_rest} is forced upon us by the diagram a morphism of coalgebras has to make commute.
   
   The same argument is used to show, again by coinduction, that any two morphisms of coalgebras $\tau,\rho : (T,\tail^T) \to (\Tri,\tail)$
   are equal, thus concluding the proof.   
\end{proof}

This universal property of coinitiality characterizes not only the codata type of infinite triangular matrices, but also
the \fat{bisimilarity} relation on it as well as the \fat{redecoration} operation.

\begin{example}
%  TODO: define codiag via universality
\end{example}


\section{Formalization in \coq}\label{sec:formal}

All our definitions and theorems are mechanized in the proof assistant \coq \parencite{coq84pl3}.
The formalization of infinite triangular matrices is taken from the work by \textcite{DBLP:conf/types/MatthesP11},
and only slightly adapted to compile with the version of \coq we use.
The mechanization does \emph{not} rely on any additional axioms.
The \coq source files and HTML documentation are available from the project web site \parencite{trimat_coq}.

In the following we explain some of our design choices for this mechanization
and point out differences between the pen-and-paper definitions and the mechanized ones.



\subsection{Implementation choices}

We explain two choices we made in the course of the formalization in \coq. The first choice concerns
the formalization of categories, more precisely, how to formalize \emph{equality of morphisms}.
The second choice concerns the formalization of algebraic structures.

\subsubsection{Setoids for hom-sets}
We formalize categories to be given by a type of objects and a dependent type---indexed by pairs of objects---of morphisms,
equipped with suitable composition and identity operations satisfying appropriate axioms.
More precisely, the family of morphisms is given by a family of \emph{setoids}, where the setoidal equivalence relation on each
type of morphisms denotes the equality relation on these morphisms. This approach was first used by
\textcite{aczel_galois} in the proof assistant \texttt{LEGO}, and also by \textcite{concat}  in their library
of category theory in \coq.
Alternatively, we could have chosen to consider morphisms modulo propositional equality.

Indeed, the morphisms we consider---morphisms of comonads and comodules---are given by structures
bundling a lot of data and properties; in order to consider two such morphisms as equal, we usually only compare one field of the 
corresponding records. Furthermore, this field usually consists of a (dependent) function.
It would be rather cumbersome to reduce equality of two such records to extensional equality of one of their fields, 
necessitating the use of the axioms of propositional and functional extensionality.
Using setoids for morphisms instead seems to come with less overhead and to be conceptually cleaner.



\subsubsection{Records vs.\ classes}
Two approaches to the formalization of mathematical structures have been used extensively in \coq: on the one hand, packaging structures
in \emph{record types}  in combination with use of \emph{canonical structures}, is used with success, e.g., in 
the formalization of algebraic structure in the context of the proof of the Feit-Thompson theorem \parencite{DBLP:conf/tphol/GarillotGMR09}.
On the other hand, \textcite{DBLP:journals/mscs/SpittersW11} suggest the use of \emph{type classes}, in particular when multiple inheritance
is an issue.

In the present formalization, we decide to use records rather than classes, since the strongest argument for type classes---multiple inheritance---does 
not occur.
We make use of canonical structures in order for \coq to deduce instances of categories when we mention objects of a category; 
in particular, this is used to allow for overloading of the notation for morphisms of a category.
We can thus conveniently use the same arrow symbol to denote the type of morphisms between two comonads, between two comodules and so on.


\subsection{Formal vs.\ informal definitions}

The only noteworthy discrepancy between formal and informal definition arises in the definition of the codata type of infinite 
triangular matrices:
in \coq, coinductive types are specified through \fat{constructors} rather than \fat{destructors}.
However, one can easily define inverse functions and work in terms of destructors afterwards.
Work on the declaration of coinductive types via destructors is done in \agda, cf.\ \parencite{DBLP:conf/popl/AbelPTS13}.
Other than that, the informal definitions correspond closely to the formalized ones---which might also stem from the fact that 
the formalization was used as a research tool, playing an essential r\^ole in the development of this work.

\section{Conclusions and future work}



We have given a category-theoretic characterization, via a universal property, of infinite triangular matrices
equipped with a comonadic redecoration operation.

While a significant part of our work---surmounting the non-categoricity of the $\cut$ operation---seems to be specific to this particular codata type,
we believe that our work proves the suitability of the notion of relative (co)monads and (co)modules thereover for 
a categorical treatment of coinductive data types.


We plan to pursue two obvious lines of work:
Firstly, we will work on a suitable notion of \emph{signature} for the specification of coinductive data types.
Secondly, we hope to integrate \emph{equations} into the notion of signature, equations which 
will allow, e.g., considering branching trees modulo permutation of subtrees.
 

\subsection*{Acknowledgments}
 We thank Ralph Matthes and Paige North for many helpful discussions, and Andr\'e Hirschowitz for providing feedback on
 a draft of this paper.

\printbibliography


% \appendix

% TODO: complete table formal
\input{formal_table}

% \input{comparison_inductive}

\end{document}



















