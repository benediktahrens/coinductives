

\pdfoutput=1

\documentclass{amsart}

\usepackage[protrusion=true,expansion=true]{microtype}


\usepackage[style=numeric,
 isbn=false,
 maxnames=3,
 maxbibnames=99 ,                
 uniquename=init ,
]{biblatex}
\bibliography{literature.bib}

\usepackage{ownstyle}


\author{Benedikt Ahrens}
\author{R\'egis Spadotti}

\title[Comodules over relative comonads for coinitial semantics]{Comodules over relative comonads \\ for coinitial semantics}

\newcommand{\fat}[1]{\textbf{#1}}

\begin{document}


\begin{abstract}
  We give a category-theoretic characterisation of heterogeneous coinductive datatypes as terminal---\enquote{coinitial}---objects.
  
  The right notion of sameness for terms of a coinductive datatype is not equality but \emph{bisimulation}.
  Consequently, we model coinductive datatypes that are parametrized by a set not as a comonad on the category of sets,
  but as a \emph{relative} comonad from sets to setoids, over a suitable functor.
\end{abstract}

\maketitle

% \tableofcontents

\section{Introduction}

 Simple inductive types---\textsf{W}-types---are characterised categorically as initial algebras of
 a polynomial functor.
 This characterisation has been extended to heterogeneous datatypes, e.g., the type of $\lambda$-terms,
 in various formulations \parencite{fpt, ahrens_relmonads}.
 
 Similarly, simple coinductive types are characterised as terminal---coinitial---algebras of polynomial functors.
 In this work we extend this characterisation to heterogeneous coinductive types.
 Our motivating example is given by the coinductive datatype of infinite triangular matrices as studied by
 \textcite{DBLP:conf/types/MatthesP11}.

 All our definitions, examples and lemmas have been implemented in the proof assistant \textsf{Coq} \parencite{coq}.
 In this document, we hence omit the proofs and focus on definitions and statements of lemmas.
 
\subsection*{Organisation of the paper}
  In \Cref{sec:preliminaries} we introduce the notions and notations used later on.
  In \Cref{sec:comonads} we recall the definition of relative comonads and define comodules over such comonads.
  Some constructions of comodules are given.
  We state our main theorem (\Cref{ex:final_sem_tri}).
  In \Cref{sec:formal} we explain some details of the formalization of this work in the proof assistant \textsf{Coq}.
 
\section{Preliminaries}\label{sec:preliminaries}


\begin{definition}[Some categories]\label{def:set_setoid}
 We denote by $\Set$ the category of sets. The category $\Setoid$ has as objects sets equiped with an equivalence relation,
 and as morphisms set-theoretic functions that are compatible with the equivalence relations of the source and target setoids.
\end{definition}



\begin{definition}\label{def:eq}
 We define $\eq : \Set\to\Setoid$ as the left adjoint to the forgetful functor 
  $U : \Setoid \to \Set$.
  More explicitly, the functor $\eq$ sends any set $X$ to the setoid $(X,=_X)$ given by the set $X$ itself, together
  with the equality relation.
\end{definition}


\begin{remark}[Notation for product]
  We denote the category-theoretic binary product of objects $A$ and $B$ of a category $\C$ by $A\times B$.
  We write $\pr_1(A,B) : A\times B \to A$ and $\pr_2(A,B) : A\times B \to B$ for the projections, and we omit the 
  argument $(A,B)$ when it is clear from the context.
  Given $f : \C(A, B)$ and $g : \C(A,C)$, we write $\langle f,g\rangle : \C(A,B\times C)$ for the induced map into the product such that
  $\comp{\langle f,g\rangle}{\pr_1} = f$ and $\comp{\langle f,g\rangle}{\pr_2} = g$.
\end{remark}

Both of the categories of \Cref{def:set_setoid} have binary products, they are \emph{cartesian monoidal}, i.e.\ the terminal 
object is neutral with respect to the multiplication. Functors preserving the monoidal structure \textbf{up to isomorphism}
are called \emph{strong monoidal}:

\begin{definition}[Strong monoidal functor]\label{def:monoidal_functor}
 A functor $F:\C\to\D$ between cartesian monoidal categories is \fat{strong monoidal} if the maps
 \[ \alpha_{A,B} := \bigl\langle F(\pr_1), F(\pr_2) \bigr\rangle : \D\bigl(F(A\times B), FA\times FB\bigr)\enspace  \] 
 are isomorphisms.
 (Note that for \emph{cartesian} monoidal categories, the family $\alpha$ of morphisms automatically makes commute the 
  diagrams necessary to have a strong monoidal functor, since it is given by universal property.)
\end{definition}

\begin{example}
  The functor $\eq: \Set \to \Setoid$ of \Cref{def:eq} is strong monoidal.
\end{example}


\section{Relative comonads and comodules over such comonads}\label{sec:comonads}

\emph{Relative monads} were defined by \textcite{DBLP:conf/fossacs/AltenkirchCU10}.
The dual notion is that of a relative \emph{co}monad:

\begin{definition}[Relative comonad]\label{def:rel_comonad}
  Let $F:\C\to\D$ be a functor. A \fat{relative comonad $T$ over $F$} is given by
  \begin{packitem}
   \item a map $T:\C_0 \to \D_0$ on the objects of the categories involved;
   \item an operation $\counit : \forall c : \C_0, \D(Tc,Fc)$;
   \item an operation $\cobind: \forall c,d:\C_0, \D(Tc,Fd) \to \D(Tc,Td)$
  \end{packitem}
  such that 
  \begin{packitem}
   \item $\forall c,d:\C_0, \forall f:\D(Tc,Fd), \comp{\cobind(f)}{\counit_d} = f$;
   \item $\forall c : \C_0, \cobind(\counit_c) = \id_c$;
   \item $\forall a,b,c:\C_0, \forall f : \D(Ta,Fb),\forall g:\D(Tb,Fc), \\
        \comp{\cobind(f)}{\cobind(g)} = \cobind(\comp{\cobind(f)}{g})$.
  \end{packitem} 
\end{definition}

Instances of relative comonads are given by some coinductive datatypes:


\begin{example}\label{ex:tri_comonad}
  \textcite{DBLP:conf/types/MatthesP11} study the coinductive datatype of infinite triangular matrices:
Let $E$ be an arbitrary fixed type.
   Infinite triangular matrices of type $A$ are given by the destructors shown in \Cref{fig:tri_destructors}.
%   \begin{lstlisting}
% Coinductive Tri (E : Set) : Set -> Set :=
%    head : forall A : Set, Tri (A) -> A.
%  | tail : forall A : Set, Tri (A) -> Tri (E x A).
%   \end{lstlisting}
% 
\begin{figure}[hbt]
  \centering
  \fbox{
    % \begin{minipage}{20em}
     \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t : \Tri(A)$}\doubleLine
     \UnaryInfC{$\head(t) : A$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t : \Tri(A)$}\doubleLine
                                       \UnaryInfC{$\tail(t) : \Tri(E\times A)$}
                                       \DisplayProof
     % \end{minipage}
       }
  \caption{Destructors of the $\Tri$ coinductive family} \label{fig:tri_destructors}
\end{figure}
\textcite{DBLP:conf/types/MatthesP11} define a notion of \emph{weak constructive comonad}, and show that infinite triangular matrices
  are an instance of such a comonad. 
  A weak constructive comonad as defined in \parencite{DBLP:conf/types/MatthesP11}, however, is \emph{precisely}
  a comonad relative to the functor $\eq : \Set\to\Setoid$.
  This yields our first example of relative comonads. 
\end{example}


Just like relative monads, relative comonads are functorial:
\begin{definition}[Functoriality for relative comonads]
 For $f : \C(c,d)$ we define
  \[ \lift^T(f) := \cobind(\comp{\counit_c}{Ff}) .  \]
 The functor properties are easily checked.
\end{definition}


In order to characterise the destructors of coinductive datatypes, we introduce the notion of \emph{comodule
over a relative comonad}:

\begin{definition}[Comodule over relative comonad]\label{def:comodule}
 Let $T$ be a relative comonad over the functor $F:\C\to\D$, and let $\E$ be a category.
 A \fat{comodule over T towards $\E$} consists of
   \begin{packitem}
   \item a map $:\C_0 \to \E_0$ on the objects of the categories involved;
   \item an operation $\mcobind: \forall c,d:\C_0, \D(Tc,Fd) \to \E(Mc,Md)$
  \end{packitem}
  such that 
  \begin{packitem}
   \item $\forall c : \C_0, \mcobind(\counit_c) = \id_c$;
   \item $\forall a,b,c:\C_0, \forall f : \D(Ta,Fb),\forall g:\D(Tb,Fc), \\
        \comp{\mcobind(f)}{\mcobind(g)} = \mcobind(\comp{\cobind(f)}{g})$ .
  \end{packitem}

\end{definition}

\begin{example}[Tautological comodule]\label{def:tautological_comodule}
  Given a relative comonad $T : \C\stackrel{F}{\to}\D$, the assignment $c \mapsto Tc$ yields a comodule over $T$ 
  with target category $\D$, the \textbf{tautological comodule} of $T$, also called $T$.
  The comodule operation is given by
    \[  \mcobind^T(f) := \cobind^T(f) \enspace . \]
\end{example}


A \emph{morphism of comodules} is given by a family of morphisms that is compatible with 
the module operation:

\begin{definition}[Morphism of comodules]\label{def:morphism_of_comodules}
 Let $M, N : \C \to \E$ be comodules over the relative comonad $T : \C \stackrel{F}{\to} \D$.
 A \fat{morphism of comodules} from $M$ to $N$ is given by a family of morphisms 
   \[ \alpha_c:\E(Mc,Nc) \]
 such that for any $c,d:\C_0$ and $f : \D(Tc,Fd)$ one has
 \[   \comp{\mcobind^M(f)}{\alpha_d} = \comp{\alpha_c}{\mcobind^N(f)} \enspace . \]
\end{definition}


Composition and identity of comodule morphisms happens pointwise. We thus obtain a category of comodules
over a fixed comonad, towards a fixed target category:

\begin{remark}[Category of comodules]
 Fix a relative comonad $\T : \C\stackrel{F}{\to}\D$ and a category $\E$.
 Comodules over $T$ towards $\E$ and their morphisms (\Cref{def:morphism_of_comodules}) form a category $\RComod(T,\E)$.
\end{remark}

Similarly to relative comonads, comodules over these are functorial:

\begin{definition}[Functoriality for modules over relative comonads]\label{def:comodule_lift}
 Let $M : \RComod(T,\E)$ be a comodule over $T$ towards some category $\E$. For $f : \C(c,d)$ we define
  \[ \mlift^S(f) := \mcobind(\comp{\counit_c}{Ff}) .  \]
\end{definition}


\begin{remark}
  The family of morphisms constituting a comodule morphism is actually natural with respect to the functoriality 
  defined in \Cref{def:comodule_lift}.
\end{remark}



%TODO: not needed for now
% \begin{definition}[Constant comodule]
%   Given $e:\E_0$, the function $\C_0\to\E_0$ sending any object of $\C$ to $e$ is equiped with
%   the structure of a comodule over $T$.
% \end{definition}

%TODO: is not needed
% \begin{definition}[Product comodule]
%  Given two comodules $M,N$ over $T$, then the pointwise product is equiped with the structure of 
%  a comodule over $T$.
% \end{definition}





\begin{definition}\label{def:extend}
 Let $F : \C\to \D$ be a strong monoidal functor between (cartesian) monoidal categories, 
 i.e.\ we have a family of isomorphisms
  \[ \alpha_{A,B} : F(A\times B) \stackrel{\sim}{\to} FA\times FB\enspace . \] 
  Let $T$ be a relative comonad over $F$, and let $E : \C$ be an object of $\C$.
 We define
 \begin{align*} \extend_{A,B} : \D(TA,FB) &\to \D\bigl(T(E\times A),F(E\times B)\bigr)\\
                                   f   &\mapsto \comp{\bigl\langle \comp{\counit_{E\times A}}{\comp{\alpha_{E,A}}{\pr_1(FE,FA)}}, \comp{\lift(\pr_2(E,A))}{f} \bigr\rangle}{\alpha_{E,B}^{-1}} \enspace .
\end{align*}
% with 
% \begin{align*}
%                \cut_A: \C(T(E\times A), TA), \quad \cut_A := \cobind_{E \times A, A}(\comp{\counit_{E \times A}}{\pr_1}) \enspace .
% \end{align*}



\end{definition}



\begin{definition}[Product in context]\label{def:product_in_context}
 Suppose $F:\C\to\D$ strong monoidal as in \Cref{def:extend}, and $T$ a comonad relative to $F$.
 Given a comodule $M$ over $T$ and an object $E:\C_0$, then precomposition with \enquote{product with $E$}
 gives a comodule $M(E\times\_)$ over $T$.
 
 The comodule operation is deduced from that of $M$ by 
 \begin{align*} \mcobind^{M(E\times\_)}_{A,B} : \D(TA,FB)&\to \E(M(E\times A), M(E\times B)) \enspace ,\\
                                                      f &\mapsto \mcobind^M_{E\times A,E\times B}(\extend(f)) \enspace .
  \end{align*}                                        

 \noindent
 Furthermore, given two comodules $M$ and $N$ over $\T$ with target category $\E$, and a comodule morphism $\alpha : M \to N$, then 
 we can define a comodule morphism \[\alpha(E\times \_) : M(E\times \_) \to N(E\times \_) \] by setting
          \[ \alpha(E \times \_)_A := \alpha_{E\times A} \enspace . \]
  
  \noindent
  We thus obtain an endofunctor on the category of comodules over $T$ towards $\E$,
   \[ M(\_) \mapsto  M (E\times \_) : \RComod(T,\E) \to \RComod(T,\E) \enspace . \]
 

\end{definition}

% \begin{definition}[Identity comodule]
% 
%   WRONG, it isn't 
%   
%   i don't delete this yet
% 
%  %TODO: identity comodule (i.e. identity functor forms a comodule over any relative comonad
%  
%  %
%  
% \end{definition}





\begin{example}\label{ex:tail_comodule}
 The destructor \lstinline!tail! of \Cref{ex:tri_comonad} is a morphism of comodules over the comonad \lstinline!Tri! 
  from the tautological comodule  $\text{\lstinline!Tri!}(\_)$ to $\text{\lstinline!Tri!}(E\times \_)$.
\end{example}


\begin{definition}[Morphism of relative comonads]
 Let $T$ and $S$ be comonads relative to a functor $F : \C \to \D$. A \fat{morphism of relative comonads} $\tau : T \to S$
  is given by a family of morphisms \[\tau_c : \D(Tc,Sc)\] such that for any $c : \C_0$,
     \[  \counit^T_c = \comp{\tau_c}{\counit^S_c} \]
   and for any $c,d : \C_0$ and $f : \D(Sc,Fd)$,
   \[  \comp{\cobind^T(\comp{\tau_c}{f})}{\tau_d} = \comp{\tau_c}{\cobind^S(f)} \enspace .  \]
\end{definition}

\begin{remark}[Category of relative comonads]
 Fix a functor $F : \C\to\D$. Relative comonads over $F$ and their morphisms form a category.
\end{remark}

%TODO: wrong, i leave it in for reference
\begin{definition}[Pullback comodule, WRONG]\label{def:pullback_comodule}
  Let $\tau : T\to S$ be a morphism of comonads relative to a functor $F : \C \to \D$, and let furthermore $M$ be a 
  comodule over $S$ towards a category $\E$. We define the \fat{pullback comodule} $\tau^*M$ to be the comodule over $T$ given by
  \[  \tau^*M(c) := Mc \]
  and 
   \[ \mcobind^{\tau^*M}(f) := \mcobind^M(\comp{\tau_c}{f}) \enspace . \]
   
  \noindent
  Pullback is functorial: if $M$ and $N$ are comodules over $S$ with codomain category $\E$, and $\alpha : M\to N$ is 
    a morphism of comodules, then we define \[\tau^*\alpha : \tau^*M \to \tau^*N\] 
    as the family of morphisms
     \[ \tau^*\alpha_c := \alpha_c \enspace . \]
\end{definition}


\begin{definition}[Pushforward comodule]\label{def:pushforward_comodule}
  Let $\tau : T\to S$ be a morphism of comonads relative to a functor $F : \C \to \D$, and let furthermore $M$ be a 
  comodule over $T$ towards a category $\E$. We define the \fat{pushforward comodule} $\tau_*M$ to be the comodule over $S$ given by
  \[  \tau_*M(c) := Mc \]
  and, for $f : \D(SA,FB)$,
   \[ \mcobind^{\tau_*M}(f) := \mcobind^M(\comp{\tau_A}{f}) \enspace . \]
   
  \noindent
  Pullback is functorial: if $M$ and $N$ are comodules over $S$ with codomain category $\E$, and $\alpha : M\to N$ is 
    a morphism of comodules, then we define \[\tau^*\alpha : \tau^*M \to \tau^*N\] 
    as the family of morphisms
     \[ \tau^*\alpha_c := \alpha_c \enspace . \]
\end{definition}


\begin{definition}[Morphism of comonads induces morphism of comodules]
  Let $\tau : T\to S$ be a morphism of comonads relative to a functor $F : \C \to \D$.
  Then $\tau$ gives rise to a morphism of comodules over $S$ from the pushforward of the tautological comodule
  of $T$ along $\tau$ to the tautological comodule over $S$,
  \[ \tau : \tau_*T \to S \enspace . \]
\end{definition}


\begin{remark}\label{rem:prod_pullback_commute}
 Note that the constructions of \Cref{def:product_in_context} and \Cref{def:pushforward_comodule} commute in the sense that
 we have an isomorphism of comodules \[\tau_*(M(E\times \_)) \cong (\tau_*M)(E \times \_) \enspace . \]
\end{remark}



\begin{theorem}[Coinitial semantics for triangular matrices]\label{ex:final_sem_tri}
   Let $\mathcal{T}$ be the category where an object is a pair $(T,t)$ of a relative comonad $T$ over the functor
   $\eq: \Set \to \Setoid$ together with a morphism of comodules $t : T \to T(E \times \_)$.
   A morphism $\tau : (T,t) \to (S,s)$ is given by a morphism of relative comonads $\tau : T \to S$ such that
   the following diagram of comodule morphisms in the category $\RComod(S,\E)$ commutes,
   
   \[     \comp{\tau_*t}{\tau(E\times \_)} = \comp{\tau}{s} \enspace , \]
   i.e.\, diagrammatically,   
   \[ \begin{xy}
       \xymatrix{   \tau_*T  \ar[r]^{\tau_*t} \ar[d]_{\tau}  &  **[r] \tau_*T (E\times \_ )\ar[d]^{\tau(E\times \_)} \\
                    S  \ar[r]_{s}  &  **[r] S (E\times \_ )
        }
      \end{xy}
   \]

   \noindent
   Here in the upper right corner we silently insert an isomorphism as in \Cref{rem:prod_pullback_commute}.
   
   Then the relative comonad of \Cref{ex:tri_comonad}, equiped with the morphism of comodules of \Cref{ex:tail_comodule},
   constitutes the terminal---\enquote{coinitial}---object in this category.
   
\end{theorem}

\section{Some more comodules}

In the following we present some more constructions of comodules which can be used to specify the type of 
destructors.

Precomposition with \enquote{product with $E$} as in \Cref{def:product_in_context} is a special case of the following
general construction:

\begin{definition}[Precomposition with a functor]
  Let $T$ be a comonad relative to $F:\C\to\D$. 
  Let $K : \C\to\C$ be an endofunctor, and $K' : \D\to\D$ be another one, and let 
  $\alpha : TK \to K'T$ and $\beta : K'F \to FK$ be natural transformations.
  We then define
  \begin{align*} \extend_K : \D(TA,FB) &\to \D(TKA,FKB)  \enspace , \\ 
                                  f  &\mapsto \comp{\alpha_{A}}{\comp{K'f}{\beta_B}}  \enspace .
  \end{align*}
%
  Any comodule $M$ over $T$ with target category $\E$ then yields a comodule $MK$ with comodule operation
  \[ \mcobind^{MK}(f) := \mcobind^M(\extend_K(f)) \enspace . \]
\end{definition}

\begin{definition}[Postcomposition with a functor]\label{def:postcomposition_functor}
  Let $T$ be a comonad relative to $F:\C\to\D$, and let $M$ be a comodule over $T$ with codomain category $\E$.
 Let $K : \E \to \X$ be a functor. Then we define the comodule $KM$ to be the comodule over $T$ with codomain category $\X$
  sending any object $A:\C_0$ to $K(MA)$.
  The comodule operation is defined by
  \[ \mcobind^{KM}(f) := K (\mcobind(f)) \enspace . 
  \]
\end{definition}

\begin{example}[Infinite branching trees]
  Let $B$ a set. We consider $B$ as a setoid via the functor $\eq:\Set\to\Setoid$, which we silently apply.
  The hom functor $Y \mapsto \Setoid(B,Y)$ is an endofunctor on the category $\Setoid$: for any two setoids $X,Y$, 
   the set of setoid morphisms $\Setoid(X,Y)$ is itself equiped with an equivalence relation.
   Branching is given by postcomposition (\Cref{def:postcomposition_functor}) with such a hom functor.
\end{example}




\section{Formalization in \texttt{Coq}}\label{sec:formal}

All our definitions and theorems are implemented in the proof assistant \texttt{Coq} \parencite{coq}.
In fact we use a non-standard version of \texttt{Coq} featuring \fat{universe polymorphism}, implemented by 
M.\ Sozeau.
% TODO: give reference. is there one?

\subsection{Implementation choices}

%TODO: setoids

\subsubsection{Setoids}

We choose to implement categories using \fat{setoids} for the dependent family of morphisms, as was first done by
\textcite{aczel_galois} in the proof assistant \texttt{LEGO}, and also used by \textcite{concat} in their library
of category theory in \texttt{Coq}.
The reason for this choice is explained in \parencite[Sec.\ 3.1.2]{ahrens_zsido}.

This choice is encouraged also by our use of a version of the \texttt{Coq} theorem prover which features \fat{universe polymorphism},
allowing to use a definition of setoids where the carrier is a \emph{field} rather than a \emph{parameter}.
% TODO: give code
In comparison, in the work by \textcite{concat}, the definitions of setoids and categories had to be repeated in order to avoid
universe inconsistencies.
As a side note, the universe polymorphism in the \texttt{Coq} version we use also allows to define the category of categories, even though
we do not make any use of that.

\subsubsection{Records vs.\ classes}

\subsection{Formal vs.\ informal definitions}

%TODO: constructors vs destructors

\section{Conclusions}

\subsection*{Acknowledgments}
 We thank Ralph Matthes and Paige North for awesome discussions about stuff.

\printbibliography

\newpage
\appendix

\input{formal_table}

\end{document}


%TODO: other arities, e.g.
%    - T(A) ---->  (E -> T(A))
%    - http://www2.tcs.ifi.lmu.de/~rodrigue/docs/types.html

