

\pdfoutput=1

\documentclass[a4paper,USenglish]{lipics}


\usepackage{csquotes}


\usepackage{mdframed}
\usepackage{ownstylelipics}



\newcommand{\parencite}[1]{\cite{#1}}

\title{Terminal semantics for codata types in intensional Martin-L\"of type theory%
\footnote{The work of Benedikt Ahrens was partially supported by the CIMI (Centre International de Mathématiques et d'Informatique) Excellence program ANR-11-LABX-0040-CIMI within the program ANR-11-IDEX-0002-02 during a postdoctoral fellowship.}
}

\author{Benedikt Ahrens}
\author{R\'egis Spadotti}

\affil{
Institut de Recherche en Informatique de Toulouse\\
Universit\'e Paul Sabatier, 
Toulouse}

\authorrunning{B.\ Ahrens and R.\ Spadotti}

\Copyright{Benedikt Ahrens and Régis Spadotti}
\subjclass{F.3.2 Semantics of Programming Languages}
% \subjclass{Dummy classification -- please refer to \url{http://www.acm.org/about/class/ccs98-html}}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
\keywords{relative comonad, Martin-Löf type theory, coinductive type, computer theorem proving}
% \keywords{Dummy keyword -- please provide 1--5 keywords}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\serieslogo{}%please provide filename (without suffix)
\volumeinfo%(easychair interface)
  {Billy Editor and Bill Editors}% editors
  {2}% number of editors: 1, 2, ....
  {Conference title on which this volume is based on}% event
  {1}% volume
  {1}% issue
  {1}% starting page number
\EventShortName{}
\DOI{10.4230/LIPIcs.xxx.yyy.p}% to be completed by the volume editor
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\fat}[1]{\textbf{#1}}
\newcommand{\itemizedist}{.5em}

\begin{document}

\maketitle


\begin{abstract}
 We study the notions of \emph{relative comonad} and \emph{comodule over a relative comonad}.
 We use these notions to give categorical semantics for the coinductive type families of streams and
 of infinite triangular matrices and their respective cosubstitution operations in intensional Martin-L\"of type theory.
 Our results are mechanized in the proof assistant \coq.
\end{abstract}




\section{Introduction}
 
 In this work, we study the notions of \emph{relative comonad} and \emph{comodule over a relative comonad}.
 We then use these notions for a case study in categorical semantics of coinductive data types in intensional Martin-Löf type theory (IMLTT): 
 we characterize two coinductive data types and their respective cosubstitution operations 
 in IMLTT via a universal property.
 The first codata type we consider is the \emph{homogeneous} type family of streams, parametrized by a base type.
 The second one is the \emph{heterogeneous} codata type family of infinite triangular matrices parametrized by the type of diagonal entries.
  In the rest of the introduction, we explain some of the vocabulary occurring in these first sentences:
  in Section \ref{sec:mltt} we briefly introduce (intensional) Martin-Löf type theory. In Section \ref{sec:sem_ind} we discuss inductive types and their semantics,
  before passing to \emph{co}inductive types in Section \ref{sec:sem_coind}.
  We describe
  the difference between homogeneous and heterogeneous (co)data types in Section \ref{sec:hom_het} and explain substitution for leaf-labeled trees and cosubstitution for node-labeled trees in Section \ref{sec:cosubst}.
  Sections \ref{sec:computer_checked} to \ref{sec:organisation} of the introduction concern more \enquote{administrative} aspects.
  
  
 \subsection{Intensional Martin-Löf type theory}\label{sec:mltt}
 Martin-Löf type theory (MLTT) \parencite{martin_lof} is a dependent type theory developed in the 1970's, which provides a foundation of mathematics.
 It is based on the Curry-Howard isomorphism, that is, it treats logic as a fragment of the general type theory.
 There are two notions of \enquote{sameness} in Martin-Löf type theory, an external (judgmental) one, and an internal (propositional) one.
 The latter is internalized by  the \emph{Martin-Löf identity type}, which is an inductively defined binary relation on any given type.
 Its only constructor relates any term to itself, that is, the relation defined by the Martin-Löf identity type is the least reflexive relation on a given type.
 Judgmentally equal terms are always propositionally equal, but the converse is not always true.
 Indeed, one distinguishes two variants of type theory: in \emph{extensional} type theory, propositional equalities (i.e.\ terms of identity type)
 are reflected, via a \emph{reflection rule}, into the judgmental equality of the type theory.  
 Here, judgmental and propositional equality thus coincide.
 \emph{Intensional} Martin-L\"of type theory  lacks the reflection principle for the sake of decidability of type checking. 
 This variant forms the basis of the computer proof assistants \coq, \matita and \agda.

 

 \subsection{Wellfounded trees and their semantics}\label{sec:sem_ind}
 
 A tree is a special kind of graph (with labeled edges and unlabeled vertices), consisting of a \emph{root} (edge), 
 to which a number of \emph{subtrees} are attached. 
 The subtrees are themselves trees.
 The root of a tree and the roots of any subtrees are more generally called \emph{nodes}.
 We gather trees of a fixed shape into a set or type, depending on the foundations we work in. 
 The possible shapes of trees are given by two data:
 \begin{enumerate}
  \item the set/type of potential nodes and
  \item the number of subtrees attached to each node.
 \end{enumerate}
 Such a pair of data is called a \emph{signature}, and we are interested in the set/type of trees which are formed according to a given signature.
 
 A tree is called \emph{wellfounded} if any of its subtrees has finite length. In this section we consider the set/type of wellfounded trees of 
 a given signature. Such a set/type is called \emph{inductively generated} by the signature. Intuitively, this set/type is the least one stable under
 forming trees starting from leaves and attaching already constructed trees as subtrees to nodes.
 One might also consider \emph{potentially infinite}, i.e., non-wellfounded trees; these are called \emph{co}inductive and are the main object of this work.
 We discuss them in Section \ref{sec:sem_coind}.
 
 
 Many objects in mathematics and logic can be represented as (wellfounded) \emph{trees}.
 For instance, a natural number can be considered as such a tree: let $\{S,Z\}$ be the set of possible nodes, 
 such that node $S$ always has one subtree and node $Z$ does not have any subtrees, i.e.\ $Z$ is a \emph{leaf}.
 The natural number $2$ is represented by the tree $S\longrightarrow S\longrightarrow Z$. 
 This example demonstrates the fundamental aspect of those tree-like objects: they can be used to model basic mathematical and logical objects.
 
  
 By \enquote{semantics of inductive types} we mean a mathematical description of the set/type of trees of a given signature. 
 More precisely, the purpose is to give a category-theoretic explanation to the above description as \enquote{the least set/type stable under forming trees}.
 However, the question of how to give such a characterization depends on the formal system we work in. 
 Below, we discuss briefly set-theoretic and type-theoretic such systems.
 
 In a set-theoretic setting, inductive sets are characterized as initial algebras for 
 some endofunctor on the category of sets \parencite{jacobs1997tutorial}.
 
 In a type-theoretic setting as given by Martin-L\"of type theory \parencite{martin_lof}, 
 two approaches to the semantics of inductive types have been studied: 
 one approach consists in showing that inductive types exist in a \emph{model} of the type theory
 (see, e.g., \cite{DBLP:journals/apal/MoerdijkP00}).
 Another approach is to prove that adding certain type-theoretic rules to the type theory---rules which postulate the existence
 of inductive types in the type theory---implies (or is equivalent to) the existence of a universal object \emph{within} type theory
 (see, e.g., \parencite{DBLP:conf/lics/AwodeyGS12, DBLP:journals/tcs/Dybjer97}).
 This latter approach is the one we adopt in the present work: we add axioms to intensional Martin-Löf type theory,
 postulating the existence of \emph{co}inductive types, see below.
 
 
 The reflection rule equips \emph{extensional} type theory with extensional features similar to those of set theory.
 As a consequence, the characterization given by Dybjer \cite{DBLP:journals/tcs/Dybjer97} of an inductive type in extensional MLTT works as in set theory: 
 an inductive type constitutes the initial algebra for some endofunctor on the category of types.
  
 
 In \emph{intensional} Martin-Löf type theory the characterization of inductive types as initial algebras of some endofunctor fails 
  for a lack of function extensionality \parencite{DBLP:journals/tcs/Dybjer97}, 
  but it can be recovered \parencite{DBLP:conf/lics/AwodeyGS12} in an \emph{extension} of intensional MLTT called
  \emph{Homotopy Type Theory} (HoTT) \parencite{hottbook}.
  In this extension, function extensionality is provable from the \emph{Univalence Axiom}. 
 For a suitable definition of \emph{uniqueness}---\emph{contractibility} in HoTT jargon---one can prove uniqueness of the
 algebra morphisms out of the one whose carrier is given by the inductive type under consideration.
 The mentioned work \parencite{DBLP:conf/lics/AwodeyGS12} thus shows that the characterization of inductive types as initial algebras carries over 
 from extensional to intensional type theory if one adds an extensionality principle for functions and adapts the notion of uniqueness.
 
 
 

 \subsection{Non-wellfounded trees: simply dualizing?}\label{sec:sem_coind}

  Coinductive sets/types describe sets/types of potentially \emph{infinite} trees, that is, trees that may have an infinite chain of subtrees---still formed according to some signature.
  An example of such a coinductive set/type is given by the \emph{co}natural numbers, which are specified by the same signature as the natural numbers.
  They consist of the elements of the natural numbers and an additional,
  infinite, tree $S \longrightarrow S\longrightarrow S \longrightarrow \ldots$. 
  
 In a traditional set-theoretic setting, the theory of coinductive sets is completely dual to that of inductive sets:
  \emph{co}inductive sets are characterized as terminal coalgebras of 
 suitable endofunctors \parencite{jacobs1997tutorial}.
 
 In intensional Martin-Löf type theory, this duality between inductive and coinductive objects breaks. This is rooted in the 
 unsuitability of the Martin-Löf identity type to express sameness for inhabitants of coinductive types:
 while identity terms are inductively generated and hence necessarily finite, 
 a proof of sameness between coinductive terms---which represent infinite objects---constitutes a potentially infinite object itself.
 The type of such proofs hence cannot be exhaustively given by the (inductive) identity type.
 
 Instead of comparing two coinductive terms in IMLTT up to identity, one defines a 
 binary coinductive relation called \emph{bisimilarity} on a given coinductive type, with respect to which one compares its inhabitants  \parencite{DBLP:conf/types/Coquand93}. 
 Categorically, \emph{bisimilarity} is given as a \emph{weakly terminal} relation on the coinductive type that is compatible with the coalgebra structure.
 Consequently, we consider two maps into a coinductive type to be the same if they are \emph{pointwise bisimilar}---an analogue
 to the aforementioned principle of function extensionality available in HoTT. 
 
 With these conventions, we give, in the present work, a characterization of some coinductive data types as \emph{terminal} object in some category 
 defined in IMLTT.
 More precisely, we consider an example of \emph{homogeneous} codata type, streams, and 
 an example of \emph{heterogeneous} codata type, triangular matrices.
 For each of these examples we prove, 
 from type-theoretic rules specifying the respective codata type added to the basic rules of IMLTT,
 the existence of a terminal object in some category \emph{within IMLTT}.
 The objects of the considered categories are not plain coalgebras for some endofunctor, but rather coalgebras with extra structure.
 This extra structure accounts for a \emph{cosubstitution} operation with which the considered codata types are endowed in a canonical way.
 The cosubstitution operation is explained in Section \ref{sec:cosubst}.

 In the present work, we do not study \emph{existence} of coinductive types. 
 In variants of IMLTT, coinductive types have been derived from inductive types: 
 for IMLTT with Uniqueness of Identity Proofs \cite{indexed_containers}, and for IMLTT augmented by the Univalence Axiom \cite{ahrens_capriotti_spadotti}.
 We are not aware of any existence result for pure IMLTT.

\subsection{Homogeneous and heterogeneous trees}\label{sec:hom_het}

Instead of considering types of trees of a given signature, we consider, more generally, \emph{families} $T(X)$ of types of trees, families parametrized by a type $X$.
We call a tree $t:T(X)$ over $X$ \emph{homogeneous} if all of its subtrees are also trees over $X$, i.e.\, if all the subtrees are elements of $T(X)$.
A signature accordingly is called homogeneous if it only admits homogeneous trees.
On the other hand, a tree $t$ is called \emph{heterogeneous}, if its subtrees $t_i$ ($i : I$ for some indexing type $I$) are trees over 
type $F_i(X)$ for maps of types $F_i : \Set \to \Set$. Obviously, for $F_i$ the identity, we obtain homogeneous trees; heterogeneous trees are thus more general than
homogeneous trees.

In the present work, we study examples of both homogeneous and heterogeneous trees: a \emph{stream} is a \emph{homogeneous} tree with one subtree over the same type of nodes,
whereas an \emph{infinite triangular matrix} is a \emph{heterogeneous} tree (over a type, say, $A$) with one subtree over type $E\times A$ for a fixed, but arbitrary type $E$.
This is explained in more detail below.

The examples we consider are trees with just one subtree. A generalization to trees (no matter whether homogeneous or heterogeneous) with a family of subtrees indexed by some fixed type $I$ as above is straightforward---we refrain from striving for this additional generality in order to keep the exposition as simple and clear as possible, and also in view of a lack of practical examples where this generality would be useful.

 

 \subsection{Cosubstitution: a comonadic operation on parametrized codata}\label{sec:cosubst}



We first consider the first case of \emph{leaf-labeled trees}.
 Let $T(X)$ be a type family of trees (of a given shape) with \emph{leaves from $X$}, i.e., $t: T(X)$ is a tree (of a given shape) with leaves in $X$.
 Let furthermore $f : X \to T(Y)$ be a map. We obtain a tree $t' : T(Y)$ by replacing any leaf of $t$ by its image under the map $f$.
 The operation of replacing any leaf in $t$ by its image under $f$ is called \emph{(simultaneous) substitution}---\enquote{simultaneous} because all the leaves are 
 substituted at the same time. 
 A well-studied example is that of the lambda calculus, the terms of which can be formalized as leaf-labeled trees over a type of \emph{free variables}, that is,
 over a \emph{context} \parencite{alt_reus}.
 More precisely, let $\LC(X)$ be the type of lambda terms in context $X$. A map $f : X \to \LC(Y)$ is called a \emph{substitution rule}, indicating how to substitute any 
 free variable $x:X$ occurring in a term $t : \LC(X)$. 
 The substitution operation (parametrized by contexts $X$ and $Y$) takes as input a lambda term $t : \LC(X)$ and a rule $f : X \to \LC(Y)$ and returns the substituted term
 $t' : \LC(Y)$.
 The categorical characterization of this substitution operation
 has been studied extensively; our list of pointers \parencite{alt_reus, fpt, Power:2007:ASS:1230146.1230276, Tanaka:2005:UCF:1088454.1088457,
 DBLP:journals/iandc/HirschowitzM10, DBLP:conf/fossacs/AltenkirchCU10, ahrens_relmonads} is necessarily incomplete.
 One such characterization is via \emph{monads}; substitution can be seen as part of a monadic structure on the functor 
 given by the parametrized data type \parencite{alt_reus, 
 DBLP:journals/iandc/HirschowitzM10, DBLP:conf/fossacs/AltenkirchCU10, ahrens_relmonads}.
 
 
 \emph{Node-labeled trees} can be equipped with a \emph{cosubstitution} operation. 
 Is this cosubstitution operation part of a comonad structure?
 In a set-theoretic setting, the fact that cosubstitution for coinductive sets is comonadic is established by Uustalu and Vene \cite{DBLP:conf/sfp/UustaluV01}.
 
  
 If we consider infinite (i.e., coinductive) node-labeled trees in IMLTT, however, the algebraic laws of cosubstitution for such trees have to be considered 
 \emph{modulo bisimilarity rather than identity}.
 For this we develop the notion of \emph{relative comonad} and \emph{comodule over a relative comonad}.
 Indeed, we show that our exemplary codata type families of streams and triangular matrices constitute relative comonads, and the maps which 
 return the substream resp.\ submatrix of a given stream resp.\ matrix constitute comodule morphisms over those relative comonads.
 
 Our goal is to characterize those codata types and their respective cosubstitution operation as a universal object in some category.
 Traditionally, codata types are characterized as terminal coalgebras of some endofunctor. However, this characterization does not account for 
 the cosubstitution operation.
 In order to integrate cosubstitution into the categorical semantics of the coinductive types under consideration,
 we thus define a more complicated category of \enquote{models} of the signature specifying those types---coalgebras with extra structure accounting for a 
 comonadic operation.
 The terminal such model is given by the codata type together with its cosubstitution operation.
 Our terminal semantics thus characterizes not only the codata types themselves but also the bisimilarity relation 
 and---via the use of (relative) comonads---a canonical cosubstitution operation on them.
 
 

 \subsection{Computer-checked proofs}\label{sec:computer_checked}

 
 All our results have been implemented in the proof assistant \coq \parencite{coq84pl4}.
 The \coq source files and HTML documentation are available online \parencite{trimat_coq}.
 Here, we hence omit the proofs and focus on definitions and statements.
 

 
 
 \subsection{Type theory vs.\ set theory} \label{sec:type_vs_set} The category-theoretic concepts studied in this work are agnostic to the foundational system being worked in.
 While we present them in a type-theoretic style, the definitions and lemmas can trivially be transferred to a set-theoretic setting.
 Throughout this article, we use type-theoretic notation,  writing $t:T$ to indicate that $t$ is of type $T$. 
 For instance, we write $f : \C(A,B)$ to indicate that $f$ is a morphism from object $A$ to object $B$ in category $\C$.
 Whenever an operation takes several arguments, we write some of them as indices; these indices might be omitted when 
 they can be deduced from the type of the later arguments.
 We assume basic knowledge of category theory; any instances used are defined in the following.
  
 
 
 \subsection{Organisation of the paper} \label{sec:organisation}
  In Section \ref{sec:preliminaries} we introduce some concepts and notations used later on.
  In Section \ref{sec:tri} we present the coinductive type families $\stream$ of streams and $\Tri$ of infinite triangular matrices and some operations on those codata types,
  in particular, the respective cosubstitution operations.
  In Section \ref{sec:comonads} we present \emph{relative comonads} and define the category of comonads relative to a fixed functor.
    We give some examples of relative comonads using the codata types presented in Section \ref{sec:tri}, 
    and relate them to traditional comonads.
  In Section \ref{sec:comodules} we define \emph{comodules over relative comonads} and give some constructions of comodules.
     Again, examples of comodules are taken from Section \ref{sec:tri}.
  In Section \ref{sec:coalgebras_for_tri} we define categories of models for the (signatures of the) codata types presented in Section \ref{sec:tri},
      based on the category-theoretic notions developed in the preceding sections.
      We then prove that the codata types constitute the terminal models in the respective categories.
      We present an example of a map defined as a terminal morphism in the category of models for streams, exploiting terminality of $\stream$.
  In Section \ref{sec:formal} we give an overview of the formalization of this work in the proof assistant \coq.
  

\section{Preliminaries}\label{sec:preliminaries}

We present a few particular category-theoretic objects used later on, and fix some notation.

\begin{definition}[Setoids in IMLTT]
  A \fat{setoid} in intensional Martin-Löf type theory is a pair $(A, \sim_A)$ of a type $A$ together with an equivalence 
  relation $\sim_A$ on $A$. Given a setoid $S = (A, \sim_A)$, we often abuse notation by writing $s:S$ instead of $s:A$ for
  a term $s$ of $A$.
  Given two setoids $(A,\sim_A)$ and $(B,\sim_B)$, the cartesian product $A\times B$ of their underlying types is equipped with
  an equivalence relation given component-wise, thus yielding a product on setoids.
\end{definition}



\begin{definition}[Category in IMLTT, \parencite{aczel_galois, concat}]
 \label{def:cat_imltt}
  A \fat{category} $\C$ in intensional Martin-Löf type theory  is given by
  \begin{itemize}
   \item a type of objects, also denoted by $\C$;
   \item for any two objects $a,b:\C$, a \emph{setoid} $\C(a,b)$ of morphisms from $a$ to $b$;
   \item an identity morphism $\id_a : \C(a,a)$ for any $a:\C$;
   \item a dependent composition operation $(\comp{}{})_{a,b,c} : \C(b,c) \times \C(a,b) \to \C(a,c)$;
   \item a proof that composition is compatible with the equivalence relations of the setoids of morphisms;
   \item proofs of unitality and associativity of composition stated in terms of the equivalence relations on the morphisms.
  \end{itemize}
  We write $f:a\to b$ for $f : \C(a,b)$, when the category $\C$ can be deduced from the context.
\end{definition}

Functors and natural transformations are defined in terms of the setoidal equivalence relations on morphisms.
We omit the definitions, which can be found in our \coq files \parencite{trimat_coq}.

\begin{definition}[Some categories in IMLTT]
\label{def:set_setoid}
 We denote by $\Set$ the category (in the sense of Definition \ref{def:cat_imltt}) of types (of a fixed universe) and total functions between them in Martin-L\"of type theory. 
 The setoidal equivalence relation on $\Set(A,B)$ is given by pointwise equality as given by the Martin-Löf identity type,
   $f \sim g \enspace =_{\text{def}} \enspace \forall x:A, fx = gx$.
 
 We denote by $\Setoid$ the category (in the sense of Definition \ref{def:cat_imltt}) an object of which is a setoid.
 A morphism between setoids is a type-theoretic function between the underlying types that is compatible in the obvious sense with the equivalence relations of the source and target setoids.
 The equivalence relation on setoid morphisms is given by pointwise equivalence:
 two parallel morphisms of setoids $f,g:A\to B$ are equivalent if for any $a:A$ we have $fa \sim_B ga$.
 The category $\Setoid$ thus is cartesian closed.
 
\end{definition}



\begin{definition}[A functor from types to setoids]
\label{def:eq}
 The functor $\eq : \Set\to\Setoid$ is defined as the left adjoint to the forgetful functor $U : \Setoid \to \Set$.
  Explicitly, the functor $\eq$ sends any type $X$ to the setoid $(X,=_X)$ given by the type $X$ itself, equipped
  with the propositional equality relation $=_X$ specified via Martin-L\"of's identity type on $X$.
\end{definition}


\begin{rem}[Notation for product]
  We denote the category-theoretic binary product of objects $A$ and $B$ of a category $\C$ by $A\times B$.
  We write $\pr_1(A,B) : \C(A\times B, A)$ and $\pr_2(A,B) :\C(A\times B, B)$ for the projections, occasionally omitting the 
  argument $(A,B)$.
  Given $f : \C(A, B)$ and $g : \C(A,C)$, we write $\langle f,g\rangle : \C(A,B\times C)$ for the induced map into the product such that
  $\comp{\langle f,g\rangle}{\pr_1} = f$ and $\comp{\langle f,g\rangle}{\pr_2} = g$.
\end{rem}

Both of the categories of Definition \ref{def:set_setoid} have finite products, i.e., binary products and a terminal object.

\begin{definition}[Product-preserving functor]
\label{def:monoidal_functor}
 A functor $F:\C\to\D$ between categories with finite products \fat{preserves finite products} if it preserves the terminal object and,
 for any two objects $A$ and $B$ of $\C$,
  the morphism $\phi^F_{A,B}$ is an isomorphism, where
 \[ \phi^F_{A,B} := \bigl\langle F(\pr_1), F(\pr_2) \bigr\rangle : F(A \times B) \to FA\times FB \enspace . \] %\D\bigl(F(A\times B), FA\times FB\bigr)\enspace . \] 
\end{definition}

\begin{example}
  The functor $\eq: \Set \to \Setoid$ of Definition \ref{def:eq} preserves finite products.
\end{example}


\section{Codata types in intensional Martin-L\"of type theory}\label{sec:tri}

In this section, two coinductive type families in intensional Martin-L\"of type theory (IMLTT) \parencite{martin_lof} are presented.
For $a,b : A$, the identity type between $a$ and $b$ is denoted by $a = b$.

We present the type-theoretic rules specifying these codata types and \emph{bisimilarity} on them.
Categorically, bisimilarity on a given codata type is given by the largest binary relation on that type that is 
compatible (in a sense to be specified later) with the \emph{observations} on that codata; it is the appropriate notion of sameness on inhabitants of these types \parencite{DBLP:conf/types/Coquand93}.
Here, an observation is the result of \emph{destructing}, i.e.\ taking apart, an element of the codata type.
For instance, an infinite list a.k.a.\ a stream (defined in detail in Example \ref{ex_stream}) over a base type $A$ allows to observe the first element---the $\shead$---of that list (which is a term of type $A$) and,
corecursively, the $\stail$ of that list, which is again an infinite list of elements of $A$.

A coinductive type together with its associated bisimilarity relation forms a setoid as in Definition \ref{def:set_setoid}.
We thus denote bisimilar elements $t$ and $t'$ by $t \sim t'$. 

A map into a codata type is defined using its \emph{introduction} rule.
Intuitively, the introduction rule takes as arguments the \emph{observations} one can make on the image of the map thus defined.
For instance, a map into streams is defined by specifying $\shead$ and $\stail$ on the output of that map: this intuition
  can be obtained by considering the combination of introduction and computation rules from Figure \ref{stream_rules}.
  We thus use a kind of \enquote{copattern matching} \parencite{DBLP:conf/popl/AbelPTS13} to define maps into streams (and analogously for other codata types): 
  the definition $f := \corec~h~t$ is written as
  the pair of clauses 
   \[\comp{f}{\shead} := h \quad \text{ and } \quad \comp{f}{\stail}:= t \enspace . \]


\noindent
The first example is the type of \emph{streams} of elements of a given base type $A$:


\begin{example}[The coinductive type family of streams]
 \label{ex_stream}
  Let $A$ be a type. A \emph{stream over $A$} is, intuitively, an infinite list of elements of $A$. 
  Given such a stream $t$, we can extract an element of $A$, called $\shead(t)$ and the rest of the stream, called $\stail(t)$, which is again a stream over $A$; see Figure \ref{fig:stream} for a schematic illustration of the two operations.
  \begin{figure}[htb]
    \centering
     \begin{tikzpicture}
      \foreach \x in {0,...,3}{\draw (\x,0) node[color=red]{$A$};};
      \draw (4,0) node[color=red]{$\dots$};
      
      \draw[color=orange] (0,-0.8) node{$\shead$};
      \draw[color=orange] (0,0) circle(0.4cm);

      
      \draw[color=green] (2,-0.8) node{$\stail$};
      \draw[color=green] (3.5, 0.3)--(0.6,0.3)--(0.6,-0.3)--(3.5,-0.3);
      \draw[color=green, dashed] (3.5,0.3)--(4.5,0.3);
      \draw[color=green, dashed] (3.5,-0.3)--(4.5,-0.3);
      
  \end{tikzpicture}
   \caption{A stream decomposes into its $\shead$ and $\stail$} \label{fig:stream}
  \end{figure}
  Formally, the type---setoid, actually---$\stream A$ of \emph{streams over $A$} is coinductively defined via the destructors $\shead$ and $\stail$
  given in Figure \ref{stream_rules}.  A map $f:T\to \stream A$ from an arbitrary type $T$ into the type of streams is specified by giving, for each possible input $t:T$, 
  an element $a:A$---the head of the image stream---and another $t':T$---an element which is mapped to $\stail~f(t)$. This intuition is made formal by the 
  introduction and computation rules of Figure \ref{stream_rules}.
  
  The second part of Figure \ref{stream_rules} introduces \emph{bisimilarity} as a binary relation on streams (over a fixed type $A$) that is compatible with the observations
  in the sense that bisimilar streams have equal $\shead$s and bisimilar $\stail$s (cf.\ the elimination rules). 
  We call a \emph{bisimulation on streams (over a given type)} any binary relation that is compatible with the observations on streams.
  If two streams are related by \emph{any} bisimulation,
  then they are also bisimilar; this is what the introduction rule declares. In that sense, bisimilarity is the largest bisimulation.

\begin{figure}
 \begin{mdframed}
  \input{stream_rules}
 \end{mdframed}
 \caption{Rules for streams and bisimilarity on them} \label{stream_rules}
\end{figure}

  
  We define a \emph{co}substition operation  on streams via the following clauses:
    
   \begin{align*} 
                  \sredec_{A,B} : (\stream A \to B) &\to \stream A\to\stream B \\
                  \comp{\sredec~f}{\shead} &:= f \quad\text{ and } \quad \\
                  \comp{\sredec~f}{\stail} &:= \comp{\stail}{\sredec~f} \enspace . %\label{eq:tail_sredec}
    \end{align*}
  According to our convention above, by this, we actually mean
  \[  \sredec_{A,B}(f) := \corec~f~\stail \enspace . \]
  We call this operation \enquote{cosubstitution} since its type is dual to the simultaneous substitution operation 
  of the lambda calculus \parencite{alt_reus}. 
  Cosubstitution is compatible with bisimilarity on streams, and thus is (the carrier of) a family
  \[ \sredec_{A,B} : \Setoid(\stream A, \eq B) \to \Setoid(\stream A,\stream B) \enspace . \]

\end{example}


\noindent
Streams are node-labeled trees where every node has exactly one subtree.
We also consider a type of trees where every node has an arbitrary, but fixed, number of subtrees, 
parametrized by a type $B$.



\begin{example}[Node-labeled trees]\label{ex_trees}
 We denote by $\Tree_B(A)$ the codata type given by one destructor $\shead$ and a family of 
 destructors $(\stail_b)_{b:B}$ with type analogous to that defining $\stail$ of Example \ref{ex_stream}.
 We thus obtain $\stream$ by considering, for $B$, the singleton type.
\end{example}


We also consider the \emph{heterogeneous} codata type family of \emph{infinite triangular matrices}:

\begin{example}\label{ex_tri}
Infinite triangular matrices are studied in detail by Matthes and Picard \cite{DBLP:conf/types/MatthesP11}.
 We give a brief summary, but urge the reader to consult the given reference 
 for an in-depth explanation. 
 The codata type family $\Tri$ of infinite triangular matrices 
 is parametrized by a fixed type $E$ for entries not on the diagonal, 
 and indexed by another, \emph{variable}, type $A$ for entries on 
 the diagonal. 
 Schematically, such a matrix looks like in Figure \ref{fig_tri}.
 \begin{figure}[hbt]
 \centering
 \begin{tikzpicture}[scale = 0.6]
    \foreach \y in {0,...,2}
    {\foreach \x in {\y,...,2}
      \draw (\x+1, -\y) node[color=blue]{$E$} ;
    }
    \foreach \x in {-1,...,3} \draw (\x, -\x-1) node[color=red]{$A$} ;
    \foreach \x in {0,...,3} \draw (\x, -\x)
    node[color=blue]{\textbf{$E$}} ;
    \draw(4,-2) node{$\ldots$};
    
    
%       \draw[color=purple!70]  (2.4, -4.3) --node[auto, swap, left]{$\cut$}
%      (-1.2,-0.6) -- (2.8,-0.6);
%     \draw[color=purple!70, dashed]  (2.8,-0.6) -- (3.6,-0.6);
%     \draw[color=purple!70, dashed]  (2.4,-4.3) -- (3.0,-5);

    \draw[color=orange] (-2,0) node{$\head$} ;
    \draw[color=orange] (-1,0) circle(0.4cm);

    \draw[color=green] (2.8,0.4) -- (-0.5,0.4) -- (-0.5, -1.1) --node[auto, swap, left]{$\tail$}
    (2.8,-4.5)  ; 
    \draw[color=green, dashed] (2.8,0.4) -- (3.6,0.4) ; 
    \draw[color=green, dashed] (2.8,-4.5) -- (3.5,-5.3) ; 


%     \draw[color=orange](0, -0.5) ellipse (12pt and 25pt) ;  
%     \draw[color=orange](1, -1.5) ellipse (12pt and 25pt) ;  
%     \draw[color=orange](2, -2.5) ellipse (12pt and 25pt) ;  
%     \draw[color=orange](3, -3.5) ellipse (12pt and 25pt) ;  
  \end{tikzpicture}\\[-2ex]
  \caption{An infinite triangular matrix over type $A$ and its destructors $\head$ and $\tail$}\label{fig_tri}
 \end{figure}

% 
 The codata type is specified via two destructors $\head$ and $\tail$, whose types are given in Figure \ref{tri_rules}.
  \begin{figure}
 \begin{mdframed}
  \input{tri_rules}
 \end{mdframed}
 \caption{Rules for triangular matrices and bisimilarity on them} \label{tri_rules}
\end{figure}
% 
 Given a matrix over type $A$, its $\tail$---obtained by removing the first element on the diagonal, i.e.\ the $\head$ element---can 
 be considered as a trapezium as indicated by the green line in Figure \ref{fig_tri}, or alternatively, as
 a triangular matrix over type $E\times A$, by bundling the entries of the diagonal with those above as indicated by the orange frames, shown in Figure \ref{fig:tri_trap}.
 The latter representation is reflected in the type of the destructor $\tail$.
 \begin{figure}[bt]
  \centering
  \begin{tikzpicture}[scale = 0.6]
    \foreach \y in {0,...,2}
    {\foreach \x in {\y,...,2}
      \draw (\x+1, -\y) node[color=blue]{$E$} ;
    }
    \foreach \x in {0,...,3} \draw (\x, -\x-1) node[color=red]{$A$} ;
    \foreach \x in {0,...,3} \draw (\x, -\x)
    node[color=blue]{$E$} ;
    \draw(4,-2) node{$\ldots$};

    \foreach \y in {0,...,2}
    {\foreach \x in {\y,...,2}
      \draw (1.5*\x+10.5, -\y) node[color=blue]{$E$} ;
    }
    \foreach \x in {0,...,3} \draw (1.5*\x+9, -\x)
    node{{\color{blue}{$E$}} \hspace*{-.5em} $\times$ \hspace*{-.5em} {\color{red} $A$}} ;
    \draw(14.5,-1.5) node{$\ldots$};
    
    \draw[->] (5,-1.5) to node[swap, auto, above]{triangle}
    (8,-1.5) ; 
    
    \draw[<-] (5,-2.5) to node[swap, auto, below]{trapezium}
    (8,-2.5) ; 

    \draw[color=green] (2.8,0.4) -- (-0.5,0.4) -- (-0.5, -1.1) --
    (2.8,-4.5)  ; 
    \draw[color=green, dashed] (2.8,0.4) -- (3.6,0.4) ; 
    \draw[color=green, dashed] (2.8,-4.5) -- (3.5,-5.3) ; 

    \draw[color=green] (13.5,0.4) -- (7.2,0.4) -- (13.5, -4); 
    \draw[color=green, dashed] (13.5,0.4) -- (14.4,0.4) ; 
    \draw[color=green, dashed] (13.5,-4) -- (14.3,-4.6) ; 

    \draw[color=orange](0, -0.5) ellipse (12pt and 25pt) ;  
    \draw[color=orange](1, -1.5) ellipse (12pt and 25pt) ;  
    \draw[color=orange](2, -2.5) ellipse (12pt and 25pt) ;  
    \draw[color=orange](3, -3.5) ellipse (12pt and 25pt) ;  
  \end{tikzpicture}\\[-2ex]
  \caption{The $\tail$ of a matrix over $A$ is a matrix over $E\times A$ (illustration taken from \parencite{DBLP:conf/types/MatthesP11})}
  \label{fig:tri_trap}
\end{figure}
% 
This change of parameter (from $A$ to $E \times A$) in the type of $\tail$ is the reason why the family $\Tri$ is called \emph{heterogeneous}.

%  As with streams, we denote by $\Tri A$ not only the resulting \emph{setoid} of triangular matrices over $A$, but also its
%  underlying \emph{type}. 
 

 

\begin{comment}
\begin{figure}[bt]
  \centering

     \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t : \Tri~A$} %\doubleLine
     \UnaryInfC{$\head_A~t : A$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t : \Tri~A$}%\doubleLine
                                       \UnaryInfC{$\tail_A~t : \Tri(E\times A)$}
                                       \DisplayProof%
% 
% 
% \vspace{2ex}
% 
 \hspace{3ex}
                                            \def\extraVskip{3pt}
     \def\proofSkipAmount{\vskip.8ex plus.8ex minus.4ex}
    \AxiomC{$t \sim t'$}%\doubleLine
     \UnaryInfC{$\head~t = \head~t'$}
      \DisplayProof
                        \hspace{3ex}
                                       \AxiomC{$t \sim t'$}%\doubleLine
                                       \UnaryInfC{$ \tail~t \sim \tail~t'$}
                                       \DisplayProof   

  \caption{Destructors and bisimilarity for the coinductive family $\Tri$} \label{fig:tri_destructors}
\end{figure}
\end{comment}
% 
% 
  A cosubstitution operation, \enquote{redecoration},
    $ \redec_{A,B} : (\Tri A \to B) \to \Tri A \to \Tri B$
  is defined  through the clauses
% 
  \begin{align} \comp{\redec~f}{\head} := f \quad\text{ and } \quad
                  \comp{\redec~f}{\tail} := \comp{\tail}{\redec~(\extend~f)} \enspace . \label{eq:rest_redec}
    \end{align}
An illustration of the redecoration operation is given in Figure \ref{fig:redec} (taken from \cite{DBLP:conf/types/MatthesP11}).    
\begin{figure}[bt]
  \centering
  \begin{tikzpicture}[scale = 0.6]
    
    \foreach \y in {0,...,2}
    {\foreach \x in {\y,...,2}
      \draw (\x+1, -\y) node[color=blue]{E} ;
    }
    \foreach \x in {0,...,3} \draw (\x, -\x) node[color=red]{A} ;
    \draw(4,-1) node{$\ldots$};

    \foreach \y in {0,...,2}
    {\foreach \x in {\y,...,2}
      \draw (\x+10, -\y) node[color=blue]{E} ;
    }
    \foreach \x in {0,...,3} \draw (\x+9, -\x) node[color=violet]{B} ;
    \draw(13,-1) node{$\ldots$};
    \draw[color=purple!70]  (2.4, -3) --
    (0.6,-1.2) -- (0.6,0.4) -- (2.4,0.4);
    \draw[color=purple!70, dashed]  (2.4,0.4) -- (3.4,0.4);
    \draw[color=purple!70, dashed]  (2.4,-3) -- (3.2,-3.7);
 
    \draw[color=orange] (1.8,-1.5) circle(2.7cm);

    \draw[color=purple!70]  (11.4, -3) --
    (9.6,-1.2) -- (9.6,0.4) -- (11.4,0.4);
    \draw[color=purple!70, dashed]  (11.4,0.4) -- (12.6,0.4);
    \draw[color=purple!70, dashed]  (11.4,-3) -- (12.5,-4.05);
    
    \draw[color=orange] (9,0) circle(0.4cm);
    
    \draw[->,color = orange] (3.9,0.5) to [bend left] node[auto,
    swap, above]{$f$} (8.8,0.5) ; 

    \draw[->,color = purple!70] (3.6,-2) to node[auto,
    swap, above]{$\redec~(\lift~f)$} (10.2,-2) ; 
    
  \end{tikzpicture}
  \caption{Definition of redecoration (illustration taken from \parencite{DBLP:conf/types/MatthesP11})}
  \label{fig:redec}
\end{figure}
% 
%     
Here, the need for the family of auxiliary functions 
     \[\extend_{A,B} : (\Tri A \to B) \to \Tri (E \times A) \to E\times B \]
  arises from the \emph{heterogeneity} of the destructor $\tail$. These functions
  are suitably defined to account for the change of the type of the argument of $\redec$ when redecorating $\tail~t : \Tri(E\times A)$
  rather than $t : \Tri A$, namely
  \[ \extend(f) := \langle \comp{\head_{E\times A}}{\pr_1(E,A)} , \comp{\cut_A}{f} \rangle \enspace . \]
  An illustration of this operation is given in Figure \ref{fig:lift} (taken from \cite{DBLP:conf/types/MatthesP11}).    
  \begin{figure}[bt]
  \centering
  \begin{tikzpicture}[scale = 0.6]
    \foreach \y in {0,...,2}
    {\foreach \x in {\y,...,2}
      \draw (\x+1, -\y) node[color=blue]{E} ;
    }
    \foreach \x in {1,...,3} \draw (\x, -\x) node[color=red]{A} ;
    \draw(4,-1) node{$\ldots$};

     \draw (7,-1.5) node{{\color{blue} E} $\times$ {\color{violet} B}} ;
    \draw[color=orange] (1,0) circle(0.4cm);
    \draw[color=orange] (6.4,-1.5) circle(0.4cm);
    \draw[color=purple!70]  (2.8, -3.4) --
     (0.1,-0.6) -- (2.8,-0.6);
    \draw[color=purple!70, dashed]  (2.8,-0.6) -- (3.6,-0.6);
    \draw[color=purple!70, dashed]  (2.8,-3.4) -- (3.5,-4.1);

    \draw[color=purple!70] (7.6,-1.5) circle(0.4cm);

     \draw[->, color = orange] (1,0.5) to [bend left] node[auto,
     swap, above]{$id$} (6.4,-0.9) ; 
    \draw[->, color = purple!70] (3.6,-2) to [bend right] node[auto,
    swap, below]{$f$} (7.5,-2) ; 
    
  \end{tikzpicture}
  \caption{Definition of lifting (illustration taken from \parencite{DBLP:conf/types/MatthesP11})}
  \label{fig:lift}
\end{figure}
% 
  The auxiliary function $\cut_A : \Tri(E\times A) \to \Tri A$ cuts the upper row of elements in $E$ of a trapezium (equivalently, of a matrix over $E\times A$).
  It is defined corecursively via
% 
  \begin{align*} \comp{\cut}{\head} := \comp{\head}{\pr_2} \quad\text{ and } \quad
                     \comp{\cut}{\tail} := \comp{\tail}{\cut} \enspace . 
      \end{align*}
%       
All the operations are suitably compatible with the bisimilarity relations, so that they can be equipped with the types
  \begin{align*}
    \redec_{A,B} &: \Setoid(\Tri A,\eq B) \to \Setoid(\Tri A,\Tri B ) \\
    \extend_{A,B} &: \Setoid(\Tri A,\eq B) \to \Setoid\bigr(\Tri (E \times A),\eq(E\times B)\bigr) \\
    \cut_A &:  \Setoid(\Tri(E\times A) , \Tri A) \enspace .
  \end{align*}
\end{example}


\begin{rem}
 We do not specify any computation rules for bisimilarity, i.e., we think of bisimilarity as a proof-irrelevant notion. 
 The lack of such a computation rule amounts to asserting that bisimilarity is a \emph{weakly} terminal bisimulation on the respective codata. 
\end{rem}


  
\section{Relative comonads and their morphisms}\label{sec:comonads}

In this section we define \emph{comonads relative to a functor} and morphisms between those, and present some examples.

\emph{Relative monads} were defined by Altenkirch, Chapman, and Uustalu \cite{DBLP:conf/fossacs/AltenkirchCU10} as a notion of monad-like structure
whose underlying functor is not necessarily an endofunctor. 
An example of relative monad given in that work is the lambda calculus over finite contexts.


The dual notion is that of a relative \emph{co}monad, more precisely, a comonad relative to some functor $F:\C\to\D$.
Indeed, since the functor underlying a relative comonad is not necessarily endo, one requires an auxiliary functor, which 
\enquote{mediates} between source and target category.
An application of this auxiliary functor is inserted where necessary to make the comonad-like operations and axioms welltyped.

\begin{definition}%[Relative comonad]
 \label{def:rel_comonad}
  Let $F:\C\to\D$ be a functor. A \fat{relative comonad $T$ over $F$} is given by
  \begin{itemize}%\setlength{\itemsep}{\itemizedist}
   \item a map $T:\C_0 \to \D_0$ on the objects of the categories involved and
   \item operations 
          \begin{align*} \counit &: \forall A : \C_0, \D(TA,FA) \\
                         \cobind &: \forall A,B:\C_0, \D(TA,FB) \to \D(TA,TB)
          \end{align*}
  \end{itemize}
   such that the following equations hold:
 \begin{align}
  & \forall A,B:\C_0, \forall f:\D(TA,FB), \comp{\cobind(f)}{\counit_B} = f \\
  & \forall A : \C_0, \cobind(\counit_A) = \id_{TA} \\
  & \forall A,B,C:\C_0, \forall f : \D(TA,FB),\forall g:\D(TB,FC), \notag \\
  &  \qquad    \comp{\cobind(f)}{\cobind(g)} = \cobind(\comp{\cobind(f)}{g}) \enspace ,
 \end{align}
   
  in diagrammatic form:
\[ \begin{xy}
    \xymatrix@C=4em{
                       TA \ar[r]^{\cobind(f)} \ar[rd]_{f}& TB \ar[d]^{\counit_B} \\
                          & FB
    }
    \end{xy}
    \qquad
    \begin{xy}
    \xymatrix{
                       TA \ar@/^1pc/[rd]^{\cobind(\counit_A)} \ar@/_1pc/[rd]_{\id}& \\
                          & TA
    }
   \end{xy}
   \qquad
   \begin{xy}
    \xymatrix@C=4em{
       TA \ar[r]^{\cobind(f)} \ar[rd]_{\cobind(\comp{\cobind(f)}{g})\;\;\;\;}& TB \ar[d]^{\cobind(g)} \\
          & TC .
    }
   \end{xy}
\]
\end{definition}




 Definition \ref{def:rel_comonad} does not mention an action of $T$ on morphisms. Indeed, just like with relative monads, this action is definable rather than part of the definition:
\begin{definition}%[Functoriality for relative comonads]
\label{def:lift}
 Let $T$ be a  comonad relative to $F:\C\to\D$.
 For $f : \C(A,B)$ we define
  \[ T(f) := \cobind(\comp{\counit_A}{Ff}) : \D(TA,TB) \enspace .\] 
 The functor properties are easily checked.
\end{definition}

\begin{rem}
 It follows from the comonadic axioms that
 counit and cobind are natural transformations with respect to the functoriality defined in Definition \ref{def:lift}:
 \begin{align*}
     \counit &: T \xrightarrow{.} F : \C\to \D \\
     \cobind &: \D(T\_, F\_) \xrightarrow{.} \D(T\_, T\_) : \C^{\text{op}} \times \C \to \Setoid \enspace .
 \end{align*}

\end{rem}





Comonads relative to the identity functor are exactly (traditional) comonads.




We obtain a comonad relative to $F:\C\to\D$ from a comonad on the category $\C$ by composing $M$ with $F$:
\begin{example}[Relative comonads from comonads]\label{ex_relcom_from_com}
  Let $F : \C \to \D$ be a fully faithful functor and $(M,\counit,\cobind)$ be a (traditional) comonad (in Kleisli form) on $\C$.
  We define a comonad $FM$ relative to $F$ by setting:
   \begin{align*}
        FM(A) &:= F(MA) \\
        \counit^{FM}_A &:= F(\counit^M_A) : \D(FMA,FA) \\
        \cobind^{FM}_{A,B} (f) &:= F\bigl(\cobind^M_{A,B}(F^{-1}f)\bigr) \enspace .
    \end{align*}

\end{example}

\noindent
The other way round does not require any conditions on the functor $F$:
\begin{example}[Relative comonads from comonads II]\label{ex_relcom_from_com_on_target}
    Let $F : \C \to \D$ be a functor and $(M,\counit,\cobind)$ be a (traditional) comonad (in Kleisli form) on $\D$.
  We define a comonad $MF$ relative to $F$ by setting:
  \begin{align*}
      MF(A) &:= M(FA)\\
      \counit^{MF}_A &:= \counit^M_{FA} : \D(MFA,FA) \\
      \cobind^{MF}_{A,B} (f) &:= \cobind^M_{FA,FB}(f) : \D(MFA,MFB) \enspace \text{ for } \enspace f : \D(MFA,FB) \enspace .
  \end{align*}
\end{example}



\noindent
The next examples concern the codata type families presented in Section \ref{sec:tri}.

\begin{example}[Streams]\label{ex_stream_comonad}
  The codata type family $\stream : \Set \to \Setoid$ of Example \ref{ex_stream} is equipped with a structure of a comonad relative to the functor 
  $\eq : \Set \to \Setoid$ with
   $\counit_A := \shead_A$ and
   $\cobind_{A,B} := \sredec_{A,B}$.
\end{example}


\begin{rem}
 Instead of considering $\stream$ as a relative comonad from $\Set$ to $\Setoid$, it could be considered as a traditional comonad on the 
 category $\Setoid$, propagating the equivalence relation on the base type, say $A$, to $\stream A$.
 The relative point of view can then be recovered as an instance of Example \ref{ex_relcom_from_com_on_target}.
\end{rem}



\begin{example}[Trees]\label{ex_tree_comonad}
 Fix a type $B$. Analogously to Example \ref{ex_stream_comonad}, the map $A \mapsto \Tree_B(A)$ of Example \ref{ex_trees}
 is equipped with a structure of a comonad relative to $\eq: \Set\to\Setoid$.
\end{example}

\begin{example}[Infinite triangular matrices]\label{ex:tri_comonad}
  The codata type family $\Tri : \Set \to \Setoid$ of Example \ref{ex_tri} is equipped with a structure of a comonad relative to the functor 
  $\eq : \Set \to \Setoid$ with
   $\counit_A := \head_A$ and
   $\cobind_{A,B} := \redec_{A,B}$.
\end{example}


\begin{rem}
  A \emph{weak constructive comonad} as defined by Matthes and Picard \cite{DBLP:conf/types/MatthesP11} to characterize the codata type $\Tri$
  and redecoration on it, is \emph{precisely}
  a comonad relative to the functor $\eq : \Set\to\Setoid$.
\end{rem}


\begin{rem}[Comonads into cartesian closed categories]
 With the notations of Definition \ref{def:rel_comonad}, suppose that the category $\D$ is cartesian closed, i.e. that $\D$ has
 internal hom-objects. This is the case, e.g., for the category $\Setoid$ of setoids.
 The cobind operation of a relative comonad into $\D$ might then be defined to be a family of arrows in $\D$,
  \begin{equation}\cobind_{A,B} : \underline{\D}(TA,FB) \to \underline{\D}(TA,TB) \enspace . \label{eq_enriched}\end{equation}
 The comonads $\stream$ (cf.\ Example \ref{ex_stream_comonad}) and $\Tri$ (cf.\ Example \ref{ex_tree_comonad}) are comonads with such a cobind operation. In these two cases, this \enquote{enriched} definition of the cobind operation given in Equation \eqref{eq_enriched} encodes a higher-order 
 compatibility of cosubstitution with bisimilarity, namely that cosubstitution with two extensionally bisimilar functions
 yields extensionally bisimilar functions.
\end{rem}


The notion of relative comonad captures many properties of $\stream$ resp.\ $\Tri$ and cosubstitution on them, in particular the interplay
of cosubstitution with the destructors $\shead$ resp.\ $\head$ via the first two axioms.
In order to  capture the interplay 
of cosubstitution  with the destructor $\stail$ (for streams) resp.\ $\tail$ (for infinite triangular matrices), 
we develop the notion of \emph{comodule over a relative comonad} and, more importantly, their morphisms, in Section \ref{sec:comodules}. 








\emph{Morphisms of relative comonads} are families of morphisms that are compatible with the comonadic structure:

\begin{definition}%[Morphism of relative comonads]
\label{def:comonad_morphism}
 Let $T$ and $S$ be comonads relative to a functor $F : \C \to \D$. A \fat{morphism of relative comonads} $\tau : T \to S$
  is given by a family of morphisms \[\tau_A : TA \to SA\] such that the following diagrams commute
  for any  $A,B : \C_0$ and $f : SA\to FB$:
%      \[  \counit^T_A = \comp{\tau_A}{\counit^S_A} \]
     
\[ \begin{xy}
    \xymatrix {
                       TA \ar[r]^{\tau_A} \ar[rd]_{\counit^T_A}  &   SA \ar[d]^{\counit^S_A}\\
                            &    FA
   }
   \end{xy}
% 
% 
%   
% 
\qquad
\begin{xy}
     \xymatrix@C=6em{
                     TA \ar[d]_{\tau_A}   \ar[r]^{\cobind^T(\comp{\tau_A}{f})} & TB \ar[d]^{\tau_B}\\
                     SA \ar[r]_{\cobind^S(f)} & SB .
     }  
   \end{xy}
\]

\end{definition}

\noindent
Relative comonads over a fixed functor $F$ and their morphisms form a category $\RComonad(F)$ with the identity and composition operations given pointwise.

\begin{rem}
A morphism $\tau : T\to S$ of relative comonads over a functor $F:\C\to\D$ is  \emph{natural}
with respect to the functorial action of Definition \ref{def:lift}.
\end{rem}


\begin{example}[Example \ref{ex_relcom_from_com} continued]\label{ex_relcom_from_com_morphism}
 Let $M$ and $M'$ be two comonads on $\C$, and let $\tau : M \to M'$ be a comonad morphism. 
 The family of morphisms \[F\tau_A := F(\tau_A) : FMA \to FM'A\] constitutes a morphism of 
 relative comonads $F\tau : FM\to FM'$.
\end{example}


\begin{rem}
 The definitions given in Examples \ref{ex_relcom_from_com} and \ref{ex_relcom_from_com_morphism} yield a functor from 
 comonads on $\C$ to comonads relative to $F:\C\to\D$. 
 If $F$ is a right adjoint with left adjoint $L$, $L\dashv F$, then postcomposing a comonad $T$ relative to $F$ with the functor $L$
 yields a monad on $\C$. Again, this map extends to morphisms.
 The two functors between categories of monads thus defined are again adjoints.
 Writing down the details is lengthy but easy.
\end{rem}



An example of comonad morphism is given by the \emph{diagonal} map which extracts the diagonal of an infinite triangular matrix (over type $A$),
yielding a stream over $A$:

\begin{example}\label{ex_diag}
We define a morphism of relative comonads $\diagonal : \Tri \to \stream$ as follows:
given a matrix $t : \Tri A$, its diagonal is a stream $\diagonal_A~t : \stream A$.
The map $\diagonal_A$ is defined via the clauses
 \begin{equation*} \comp{\diagonal_A}{\shead} := \head \quad\text{ and } \quad %\notag\\
                  \comp{\diagonal_A}{\stail} := \comp{\comp{\tail}{\cut}}{\diagonal_A} \enspace . %\label{eq:diag}
 \end{equation*}
Instead of proving the comonad morphism axioms for this map, we will, in Example \ref{ex_diag_terminal}, specify the same map via a universal property. 
There, the compatibility of this map with 
cosubstitution on source and target will follow for free.



\end{example}



\begin{rem}[Non-examples]
 The family of destructors $\stail_A : \stream A \to \stream A$  
 does \emph{not} satisfy the axioms for a morphism of relative comonads $\stream\to\stream$.
 
 Similarly, while the map $A \mapsto \Tri(E\times A)$ inherits the structure of a relative comonad (see Definition \ref{product_comonad}),
 the family $\tail_A : \Tri A \to \Tri(E \times A)$  does \emph{not} constitute a comonad morphism
 of type $\Tri \to \Tri(E \times \_)$.
\end{rem}

Let $\C$ be a category with products and $E:\C_0$ be an object of $\C$.
The following definition shows how a relative comonad $T$ with domain category $\C$ gives rise to a relative comonad with underlying object map
$A \mapsto T(E\times A)$.
We shall not make use of this definition in what follows: indeed, in Section \ref{sec:coalgebras_for_tri} we consider the map $A\mapsto T(E\times A)$
as a \emph{comodule} over $T$, rather than a comonad. The below definition may thus be skipped by the reader.

\begin{definition}\label{product_comonad}
  Let $T$ be a comonad relative to a product-preserving functor $F:\C\to\D$ between categories with finite products,
  and let $E:\C_0$ be a fixed object of $\C$.
 The map $A\mapsto T(E\times A)$ inherits the structure of a comonad relative to $F$ from $T$: the 
 counit is defined as
   \[ \counit_A := \comp{T(\pr_2(E,A))}{\counit^T_{A}} \]
  and the cobind operation as
   \begin{align*} 
            \cobind_{A,B} : \D\bigl(T(E\times A),FB\bigr) &\to \D\bigl(T(E\times A),T(E\times B)\bigr) \\
              f &\mapsto  \cobind^T(\extend'~f)
   \end{align*}
  with $\extend'$ defined as 
  \begin{align*} \extend' : \D\bigl(T(E\times A),FB\bigr) &\to \D\bigl(T(E\times A), F(E\times B)\bigr) \enspace , \\ 
                                            f & \mapsto \comp{\langle \comp{T(\pr_1)}{\counit^T_E}, f \rangle}{{\phi^{F}_{E,B}}^{-1}} \enspace .
  \end{align*}
\end{definition}




\section{Comodules over relative comonads}\label{sec:comodules}

In this section we develop the notion of \emph{comodule over a relative comonad}, dualizing the notion of module over a relative monad \parencite{ahrens_relmonads}.
Our motivation for developing this notion is the characterization of the destructors $\stail$ and $\tail$ as \emph{morphisms of comodules}.

\begin{definition}%[Comodule over relative comonad]
\label{def:comodule}
 Let $T$ be a comonad relative to $F:\C\to\D$, and let $\E$ be a category.
 A \fat{comodule over T towards $\E$} consists of
   \begin{itemize}\setlength{\itemsep}{\itemizedist}
   \item a map $M:\C_0 \to \E_0$ on the objects of the categories involved and
   \item an operation \[\mcobind: \forall A,B:\C_0, \D(TA,FB) \to \E(MA,MB)\] such that the following equations hold:
 \begin{align}
 &  \forall A : \C_0, \mcobind(\counit_A) = \id_{MA} \\
 & \forall A,B,C:\C_0, \forall f : \D(TA,FB),\forall g:\D(TB,FC), \notag\\
 &   \qquad      \comp{\mcobind(f)}{\mcobind(g)} = \mcobind(\comp{\cobind(f)}{g}) \enspace ,
 \end{align}
  in diagrammatic form:
\[
    \begin{xy}
    \xymatrix{
                       MA \ar@/^1pc/[rd]^{\mcobind(\counit_A)} \ar@/_1pc/[rd]_{\id}& \\
                          & MA
    }
   \end{xy}
   \qquad
   \begin{xy}
    \xymatrix@C=4em{
       MA \ar[r]^{\mcobind(f)} \ar[rd]_{\mcobind(\comp{\cobind(f)}{g})\;\;\;\;\;}& MB \ar[d]^{\mcobind(g)} \\
          & MC .
    }
   \end{xy}
\]  
  
  
  \end{itemize}

\end{definition}


Similarly to relative comonads, comodules over these are functorial:
\begin{definition}[Functoriality for comodules]
\label{def:comodule_lift}
 Let $M : \RComod(T,\E)$ be a comodule over $T$ towards some category $\E$. For $f : \C(A,B)$ we define
  \[ M(f) := \mcobind(\comp{\counit_A}{Ff}) \enspace .  \]
\end{definition}

\noindent
Every relative comonad constitutes a comodule over itself, the \emph{tautological} comodule:

\begin{definition}[Tautological comodule]
\label{def:tautological_comodule}
  Given a comonad $T$ relative to $F:\C\to\D$, the map $A \mapsto TA$ yields a comodule over $T$ 
  with target category $\D$, the \textbf{tautological comodule} of $T$, also called $T$.
  The comodule operation is given by
    $  \mcobind^T(f) := \cobind^T(f)$. 
\end{definition}

\noindent
A more interesting example of comodule is given by the functor that maps a type $A$ to the setoid $\Tri(E\times A)$
for some fixed type $E$:
\begin{example}\label{ex_tri_prod_comod}
   The map $A \mapsto \Tri(E\times A)$ is equipped with a comodule structure over the relative comonad $\Tri$ by
   defining the comodule operation $\mcobind$ as (cf.\ Example \ref{ex_tri})
     \[ \mcobind_{A,B} (f) := \redec_{E\times A, E\times B} (\extend~f) \enspace \text{ for } \enspace f : \Setoid(\Tri A, \eq B) \enspace . \]
\end{example}

In Section \ref{sec:coalgebras_for_tri} we generalize Example \ref{ex_tri_prod_comod}---precomposition with a product---to more general relative comonads over suitable categories.
However, this requires an axiomatization of the $\extend$ operation, more precisely of an important building block of it, the
$\cut$ operation.

A \emph{morphism of comodules} is given by a family of morphisms that is compatible with 
the comodule operation:

\begin{definition}[Morphism of comodules]
\label{def:morphism_of_comodules}
 Let $M$ and $N : \C \to \E$ be comodules over the comonad $T$ relative to  $F:\C \to \D$.
 A \fat{morphism of comodules} from $M$ to $N$ is given by a family of morphisms 
   $ \alpha_A:\E(MA,NA) $
 such that for any $A,B:\C_0$ and $f : \D(TA,FB)$ one has
 \[\comp{\mcobind^M(f)}{\alpha_B} = \comp{\alpha_A}{\mcobind^N(f)} \enspace, \]
 in diagrammatic form
 \[
  \begin{xy}
   \xymatrix@C=6em{
     MA  \ar[r]^{\mcobind^M(f)}  \ar[d]_{\alpha_A} & MB \ar[d]^{\alpha_B} \\
     NA  \ar[r]_{\mcobind^N(f)}  & NB.
   }
  \end{xy}
 \]

\end{definition}

\noindent
Composition and identity of comodule morphisms happens pointwise. We thus obtain a category $\RComod(T,\E)$
 of comodules
over a fixed comonad $T$, towards a fixed category $\E$.

The motivating examples for us to consider comodules and their morphisms are the following:

 \begin{example}\label{ex_tail_comodule}
  The family of destructors $\stail_A : \stream A \to \stream A$, indexed by a type $A$, is the carrier of a morphism of tautological comodules (over the relative comonad $\stream$),
  \[ \stail : \stream \to \stream \enspace . \]
 \end{example}

\begin{example}\label{ex:tail_comodule}
 The family of destructors $\tail_A : \Tri A \to \Tri(E\times A)$, indexed by a type $A$, of Example \ref{ex_tri} is a morphism of comodules over the comonad $\Tri$ 
  from the tautological comodule  $\Tri$ to the comodule $\Tri(E\times \_)$ as defined in Example \ref{ex_tri_prod_comod},
  \[ \tail : \Tri \to \Tri(E\times \_) \enspace . \]
\end{example}




\begin{rem}
  The family of morphisms constituting a comodule morphism is actually natural with respect to the functoriality 
  defined in Definition \ref{def:comodule_lift}.
\end{rem}

Given a morphism of comonads, we can \enquote{transport} comodules over the source comonad to comodules over the target comonad:


\begin{definition}[Pushforward comodule]
\label{def:pushforward_comodule} 
  Let $\tau : T\to S$ be a morphism of comonads relative to a functor $F : \C \to \D$, and let furthermore $M$ be a 
  comodule over $T$ towards a category $\E$. We define the \fat{pushforward comodule} $\tau_*M$ to be the comodule over $S$ given by
  $  \tau_*M(A) := MA $
  and, for $f : \D(SA,FB)$,
   \[ \mcobind^{\tau_*M}(f) := \mcobind^M(\comp{\tau_A}{f}) : \E(MA,MB) \enspace . \]
   
  \noindent
  Pushforward is functorial: if $M$ and $N$ are comodules over $T$ with codomain category $\E$, and $\alpha : M\to N$ is 
    a morphism of comodules, then we define 
     $\tau_*\alpha : \tau_*M \to \tau_*N$
    as the family of morphisms
     $ (\tau_*\alpha)_A := \alpha_A$.
  It is easy to check that this is a morphism of comodules (over $S$) between $\tau_*M$ and $\tau_*N$.
  Pushforward thus yields a functor \[\tau_*:\RComod(T,\E) \to \RComod(S,\E) \enspace . \]
\end{definition}


As presented in Definition \ref{def:tautological_comodule}, every relative comonad induces a comodule over itself.
This extends to morphisms of relative comonads in the following sense:

\begin{definition}%[Morphism of comonads induces morphism of comodules]
\label{def:induced} 
  Let $\tau : T\to S$ be a morphism of comonads relative to $F : \C \to \D$.
  Then $\tau$ gives rise to a morphism of comodules over $S$ from the pushforward of the tautological comodule
  of $T$ along $\tau$ to the tautological comodule over $S$,
  \[ \induced{\tau} : \tau_*T \to S \enspace , \quad \induced{\tau}_A := \tau_A \enspace . \]
\end{definition}
% 
We conclude the section with some constructions of comodules:

\begin{lemma}
Let $T$ be a comonad relative to $F : \C \to \D$, and let $M : \C \to \E$ be a comodule over $T$.
Let $G : \E \to \X$ be a functor.
Then $(G \circ M, G\circ \mcobind^M)$ is a comodule over $T$.
This extends to morphisms of comodules: for $N$ another comodule over $T$ with target category $\E$, and $\alpha : M \to N$ a morphism of comodules,
$G \circ \alpha, c \mapsto G(\alpha_c)$
is a morphism of comodules from $G \circ M$ to $G \circ N$.
This yields a functor
$\RComod(T,\E) \to \RComod(T,\X)$. 
\end{lemma}

In particular, given any object $e:\E_0$, the constant functor $\C\to\E$ mapping to $e$ is a comodule for any comonad relative to $F:\C\to\D$.

\begin{lemma}
Let $T$ be a comonad relative to $F : \C \to \D$, and let $M : \C \to \E$ be a comodule over $T$.
Let $G : \C \to \C$ be an endofunctor.
Then $(M \circ G, \mcobind^M \circ G)$ is a comodule over $T$.
This extends to morphisms of comodules: for $N$ another comodule over $T$ with target category $\E$, and $\alpha : M \to N$ a morphism of comodules,
$\alpha \circ G, c \mapsto \alpha_{Gc}$
is a morphism of comodules from $M \circ G$ to $N \circ G$.
This yields an endofunctor
$\RComod(T,\E) \to \RComod(T,\E)$. 
\end{lemma}

\begin{lemma}
Let $T$ be a comonad relative to $F : \C \to \D$, and let $M, N: \C \to \E$ be comodules over $T$.
Suppose that $\E$ has coproducts, denoted $e + e'$.
Then $M + N, c \mapsto M c + N c$ is a comodule over $T$, with cosubstitution given by $\mcobind^M + \mcobind^N$.
This construction extends to a coproduct on $\RComod(T,\E)$. 
\end{lemma}



\section{Terminality for streams and infinite triangular matrices}\label{sec:coalgebras_for_tri}

In this section, we define a notion of \enquote{model} for the signatures of streams and triangular matrices,
respectively. We then show that the codata types $\stream$ and $\Tri$ constitute the terminal object in
the respective category of models.


This terminal semantics result is hardly surprising; however, it is still interesting as it characterizes not only the codata types themselves,
 but also the respective bisimilarity relations and comonadic operations on them, via a universal property.



\subsection{Models for $\stream$}

We first consider the homogeneous codata type of streams.

\begin{definition}[Category of models for $\stream$]
 \label{cat_stream}
  A \fat{model for $\stream$} is given by a pair $(S,t)$ 
  consisting of
  \begin{itemize}
   \item a comonad $S$ relative to $\eq : \Set \to \Setoid$ and
   \item a morphism $t$ of tautological comodules over $S$, 
                   \[t : S \to S \enspace . \]
  \end{itemize}
  A \fat{morphism of models} $(S,t) \to (S',t')$ is given by a comonad morphism $\tau : S \to S'$ such that
     $ \comp{\tau_*t}{\induced{\tau}} = \comp{\induced{\tau}}{t'}$, in diagrammatic form,
 \[
  \begin{xy}
   \xymatrix{
                  S \ar[r]^{\tau_*t} \ar[d]_{\induced{\tau}} & S \ar[d]^{\induced{\tau}}\\
                  S' \ar[r]_{t'} & S' .
   }
  \end{xy}
 \]
  Note that the above diagram is a diagram in the category $\RComod(S', \Setoid)$. 
  
  This defines a category of models of the signature of streams, with composition and identity inherited from those of comonad morphisms.

\end{definition}

In the introduction we mentioned a more traditional notion of \enquote{model} for a signature of a coinductive data type, 
namely that of a coalgebra of some endofunctor. The relationship between models as in Definition \ref{cat_stream} and coalgebras is as follows:

\begin{rem}[Coalgebras for streams: forgetting cosubstitution]\label{rem:coalg_stream}
 Define the functor
  \begin{align*}  F: [\Set,\Setoid] \to [\Set,\Setoid]  \enspace , \enspace
                      F(G)(A) := \eq(A) \times G(A) \enspace .
  \end{align*}
  Then we have a forgetful functor from models for streams (in the sense of Definition \ref{cat_stream}) to coalgebras of $F$ which, intuitively, forgets the cosubstitution structure.
  Indeed, given a model $(S,t)$, the comonad $S$ is, in particular, a functor $S:\Set\to\Setoid$ which constitutes the carrier of 
  a coalgebra of $F$: the coalgebra structure map $S \to F(S):=\eq\times S$, as a map into a product, 
  is assembled from the counit of $S$ as the first component, and the comodule morphism $t:S\to S$, which
  is a natural transformation $t : S \to S$ as the second component.
\end{rem}
  
  The reason why we consider the richer notion of model (as compared to coalgebras) is that we want the objects of 
  our category---and thus in particular the terminal object---to be equipped with a well-behaved \enquote{cosubstitution} operation.
  It is this cosubstitution operation which is modeled by the comonad and comodule structure, and which is forgotten by 
  the forgetful functor defined above.

  
  The category of models for $\stream$ has a terminal object:
  
\begin{theorem}\label{thm_stream_terminal}
 The pair $(\stream, \stail)$, where $\stream$ is considered as a relative comonad and $\stail$ as
 a morphism of comodules, is the terminal object in the category of models of Definition \ref{cat_stream}.
\end{theorem}

More precisely, Theorem \ref{thm_stream_terminal} says that the rules given in Figure \ref{stream_rules} allow to prove that
the category of models defined in Definition \ref{cat_stream} has a terminal object.
The proof of Theorem \ref{thm_stream_terminal} being essentially the same as that of Theorem \ref{thm:final_sem_tri}, we omit the former.
However, a mechanized proof can be found in our \coq library, see Section \ref{sec:formal}.


The property of being terminal can be used to specify a map into streams, by equipping some comonad $S$ relative to $\eq:\Set\to\Setoid$
with the structure of a model for streams, that is, with a comodule morphism $S\to S$.
We do so for the comonad $\Tri$:

\begin{example}\label{ex_diag_terminal}
  We equip the relative comonad $\Tri$ with the structure of a model for $\stream$ by defining a 
  morphism of tautological comodules over $\Tri$, given by the composition
   \[ t^{\diagonal} := \comp{\tail}{\cut}  : \Tri \to \Tri \enspace . \]
  By terminality we obtain a morphism of models
   \[(\Tri, t^{\diagonal}) \to (\stream, \stail) \] 
  which has, as underlying morphism of relative comonads, the one defined in Example \ref{ex_diag}. 
  Compatibility of this map with cosubstitution in $\Tri$ and $\stream$, respectively,
  is for free.
\end{example}

 
\begin{rem}
 Fix a type $B$. A result analogous to Theorem \ref{thm_stream_terminal} holds for trees $\Tree_B$ of Example \ref{ex_tree_comonad}. 
 We refrain from giving a precise statement of this result.
\end{rem}


\subsection{Models for $\Tri$}

In analogy to the definition of models for the signature of streams, one would like to define
a model for the signature of $\Tri$ as a pair $(T,r)$ of a comonad $T$ relative to $\eq : \Set \to \Setoid$ and 
a morphism of comodules $r : T \to T(E\times \_)$. 
It turns out that in this way, one does not obtain the right auxiliary function $\cut$ for what is
supposed to be the \emph{terminal} such model, the pair $(\Tri,\tail)$, where $\cut$ is used to define the comodule $\Tri(E\times \_)$.
As a remedy, we define a model to come equipped with a specified operation analogous to $\cut$, and some laws governing
the behavior of that operation:




\begin{definition}%[Relative comonad with cut]
\label{def:rel_comonad_with_cut}
 Let $\C$ and $\D$ be categories with binary products and $F:\C\to\D$ a product-preserving functor. Let $E:\C_0$ be a fixed object of $\C$.
 We define a \fat{comonad relative to $F$ with cut relative to $E$} to be a comonad $T$ relative to $F$ together with a $\cut$ operation 
    \[ \cut : \forall~A:\C_0, T(E\times A) \to TA \]
%   
 satisfying the axioms
  \begin{itemize}
%    \item $\forall~A:C_0, \comp{\cut_A}{\counit_A} = \comp{\counit_{E\times A}}{F(\pr_2(E,A))}$;
   \item $\forall~A:C_0, \comp{\cut_A}{\counit_A} = \comp{T(\pr_2(E,A))}{\counit_{A}}$;
   \item $\forall~A~B:C_0,\forall~f:\D(TA,FB), \comp{\cut_A}{\cobind(f)} = \comp{\cobind(\extend~f)}{\cut_B}$,
  \end{itemize}
that is,
\[
 \begin{xy}
  \xymatrix@C=5em{
                T(E\times A) \ar@<1ex>[r]^-{T(\pr_2(E,A))} \ar@<-1ex>[r]_-{\cut_A} & TA \ar[r]^{\counit_A} & FA
  }
 \end{xy}
 \quad\text{ and } \quad
 \begin{xy}
  \xymatrix@C=5em{
	      T(E\times A) \ar[r]^{\cobind(\extend~f)} \ar[d]_{\cut_A} & T(E\times B) \ar[d]^{\cut_B} \\
	      TA \ar[r]_{\cobind(f)} &  TB 
  }
 \end{xy}
\]


  \noindent
  where, for $f:\D(TA,FB)$, we define $\extend(f) : \D\bigl(T(E\times A),F(E\times B)\bigr)$ as
       \[ \extend(f) := \comp{\comp{\langle T(\pr_1) , \cut \rangle}{(\counit_E\times f)}}{{\phi^{F}_{E,B}}^{-1}} \enspace . \]
  
\end{definition}

\noindent
Morphisms of comonads with cut are morphisms of comonads that are compatible with the respective $\cut$ operations:

\begin{definition}%[Morphism of comonads with cut]
\label{def:morphism_comonad_cut}
 Let $(T,\cut^T)$ and $(S,\cut^S)$ be two comonads relative to a functor $F$ with cut relative to $E$ as in Definition \ref{def:rel_comonad_with_cut}.
 A \fat{morphism of comonads with cut} is a comonad morphism $\tau$ between the underlying comonads as in Definition \ref{def:comonad_morphism} that 
 commutes suitably with the respective $\cut$ operations, i.e.\ for any $A : \C_0$,
  $\comp{\tau_{E \times A}}{\cut^S_A}  = \comp{\cut^T_A}{\tau_A}$:
\[
 \begin{xy}
  \xymatrix@C=4em{
                 T(E\times A)   \ar[r]^-{\cut^T_A} \ar[d]_{\tau_{E \times A}}  & TA \ar[d]^{\tau_{A}}\\
                 S(E \times A)  \ar[r]_-{\cut^S_A}   & S A.
  }
 \end{xy}
\]

\end{definition}


Comonads with cut relative to a fixed functor $F:\C\to\D$ and $E:\C_0$ form a category $\RComonadWC(F,E)$.
There is a forgetful functor from $\RComonadWC(F,E)$ to $\RComonad(F)$.
Conversely, any comonad $T$ relative to a suitable functor can be equipped with a $\cut$ operation, using functoriality of $T$.
%

\begin{rem}[Canonical $\cut$ operation]\label{canonical_cut}
 Any comonad $T$ relative to a product-preserving functor $F:\C\to\D$  can be equipped with a $\cut$ operation relative to 
 $E:\C_0$ satisfying the properties of Definition \ref{def:rel_comonad_with_cut} by setting
   \[ \ccut_A := \cut_A := T\bigl(\pr_2(E,A)\bigr) \enspace . \]
 (The extra \enquote{c} of $\ccut$ stands for \enquote{canonical}.)
 It follows from the axioms of comonad morphisms that a comonad morphism $\tau : T\to S$ satisfies the equation of Definition \ref{def:morphism_comonad_cut} 
 for the  operations $\ccut^T$ and $\ccut^S$ thus defined. The morphism $\tau$ hence constitutes a morphism of comonads with cut from $(T,\ccut^T)$ to $(S,\ccut^S)$.
 We thus obtain a functor 
 \[ \ccut_{F,E} : \RComonad(F) \to \RComonadWC(F,E)\]
 from relative comonads over $F$ to relative comonads over $F$ with cut relative to a fixed object $E:\C_0$ given on 
 objects by $T\mapsto (T,\ccut^T)$.
\end{rem}

The functor $\ccut_{F,E}$, followed by the forgetful functor, yields the identity. We can thus view
relative comonads with cut as a generalization of relative comonads.

Our prime example of relative comonad comes with a $\cut$ operation that is \emph{not} the canonical one:

\begin{example}%[$\cut$ for $\Tri$]
\label{def:cut_for_tri}
  The relative comonad $\Tri$ from Example \ref{ex:tri_comonad}, together with the $\cut$ operation defined in Example \ref{ex_tri}, 
  is a comonad with cut as in Definition \ref{def:rel_comonad_with_cut}.
\end{example}





Given a comodule $M$ over a relative comonad $T$ with cut, we define a comodule over $T$ obtained by precomposition of $M$ with
\enquote{product with a fixed object $E$}:


\begin{definition}%[Precomposition with product]
\label{def:product_in_context}
 Suppose $F:\C\to\D$ is a product-preserving functor, and $T$ is a comonad relative to $F$ with a $\cut$ operation 
 relative to $E:\C_0$ as in Definition \ref{def:rel_comonad_with_cut}.
 Given a comodule $M$ over $T$,  \fat{precomposition with} \enquote{\fat{product} with $E$}
 gives a comodule 
   \[ M(E\times\_) : A \mapsto M(E\times A) \] over $T$.
 The comodule operation is induced by that of $M$ by 
 \begin{align*} \mcobind^{M(E\times\_)}_{A,B} : \D(TA,FB)&\to \E\bigl(M(E\times A), M(E\times B)\bigr) \enspace ,\\ 
                                                      f &\mapsto \mcobind^M_{E\times A,E\times B}(\extend(f)) \enspace ,
  \end{align*}                                        
where the $\extend$ operation is the one defined in Definition \ref{def:rel_comonad_with_cut}.
 
 Furthermore, given two comodules $M$ and $N$ over $\T$ with target category $\E$, and a comodule morphism $\alpha : M \to N$,  
 the assignment \[ \alpha(E \times \_)_A := \alpha_{E\times A} \] defines a comodule morphism 
  $\alpha(E\times \_) : M(E\times \_) \to N(E\times \_) $.

  \noindent
  We thus obtain an endofunctor on the category of comodules over $T$ towards $\E$,
   \[ M \mapsto  M (E\times \_) : \RComod(T,\E) \to \RComod(T,\E) \enspace . \]
\end{definition}



\begin{rem}[Pushforward commutes with product in context]\label{rem:prod_pullback_commute}
 The constructions of Definitions \ref{def:product_in_context} and \ref{def:pushforward_comodule} commute:
 we have an isomorphism of comodules 
  \[     \tau_*(M(E\times \_)) \cong (\tau_*M)(E \times \_)        \]
 given pointwise by identity morphisms.
\end{rem}



It directly follows from the definition that the cut operation of any comonad $T$ with cut 
constitutes a comodule morphism $\cut : T(E\times \_) \to T$.
We can thus restate the definition of a morphism of comonads with cut as in Definition \ref{def:morphism_comonad_cut} by asking the following diagram 
of comodule morphisms (in the category $\RComod(S,\D)$) to commute
(where in the upper left corner we silently add an isomorphism as in Remark \ref{rem:prod_pullback_commute}):
 \[ \begin{xy}
       \xymatrix{  **[l] \tau_*T(E\times \_ )  \ar[r]^{\tau_*(\cut^T)} \ar[d]_{\induced{\tau}(E\times \_)}  &  **[r] \tau_*T \ar[d]^{\induced{\tau}} \\
                   **[l]  S (E\times \_ ) \ar[r]_{\cut^S}  &  **[r] S  \enspace .
        }
      \end{xy}
   \]



\noindent
The construction of Definition \ref{def:product_in_context} yields a categorical characterization of the $\tail$ destructor---%
more precisely, of its behavior with respect to cosubstitution as in Equation \ref{eq:rest_redec}---via the notion of comodule morphism:


\begin{example}\label{ex:tail_comodule_alternative}
Definition \ref{def:product_in_context} is an axiomatization of Example \ref{ex:tail_comodule}:
the relative comonad $\Tri$ is a relative comonad with cut, and 
the family of destructors $\tail_A : \Tri A \to \Tri (E\times A)$ constitutes a morphism of comodules
\[ \tail : \Tri \to \Tri (E \times \_ ) \]
from the tautological comodule $\Tri$ to the composed comodule $\Tri (E\times \_)$ (obtained by precomposing the tautological comodule $\Tri$
with \enquote{product with $E$} as defined in Definition \ref{def:product_in_context}).
  
\end{example}


The axiomatization of the cut operation now allows us to define models for the signature of infinite triangular matrices:

\begin{definition}[Models for infinite triangular matrices]
\label{def:cat_tri}
   Let $E:\Set$ be a fixed type.
   Let $\mathcal{T} = \mathcal{T}_E$ be the category of \fat{models for infinite triangular matrices} where an object is a pair $(T,\tail^T)$ consisting of
   \begin{itemize}
    \item a comonad $T$ over the functor $\eq:\Set\to\Setoid$ with $\cut$ relative to $E$ and
    \item a morphism $\tail^T$ of comodules over $T$ of type $T \to T(E\times \_)$
   \end{itemize}
   such that for any set $A$,
    $ \comp{\cut^T_A}{\tail^T_A} = \comp{\tail^T_{E\times A}}{\cut^T_{E\times A}}$.
    
   The last equation can be stated as an equality of comodule morphisms, diagrammatically
%      \[ \comp{\cut}{\tail} = \comp{\tail(E\times \_)}{\cut(E\times\_)} \quad \bigl( = (\comp{\tail}{\cut})(E\times \_)\bigr)\enspace . \]
   \[
    \begin{xy}
     \xymatrix@C=5em{
                    **[l]  T(E\times \_) \ar[d]_{\cut^T} \ar[r]^-{\tail^T(E\times \_ )} & **[r] T(E \times E \times \_)  \ar[d]^{\cut^T(E\times\_)} \\
                     **[l] T \ar[r]_{\tail^T} & **[r] T (E\times \_).
     }
    \end{xy}
   \]

  
   \noindent
   A morphism between two such objects $(T,\tail^T)$ and $(S,\tail^S)$
   is given by a morphism of relative comonads with cut $\tau : T \to S$ such that
   the following diagram of comodule morphisms in the category $\RComod(S,\E)$ commutes,
% \begin{multicols}{2}   
   \begin{equation} \begin{xy}
       \xymatrix{   \tau_*T  \ar[r]^{\tau_*(\tail^T)} \ar[d]_{\induced{\tau}}  &  **[r] \tau_*T (E\times \_ )\ar[d]^{\induced{\tau}(E\times \_)} \\
                    S  \ar[r]_{\tail^S}  &  **[r] S (E\times \_ ) \enspace .
        }
      \end{xy}
      \label{eq:tri_model}
   \end{equation}
   Here we silently insert an isomorphism as in Remark \ref{rem:prod_pullback_commute} in the upper right corner.
% \end{multicols}
\end{definition}   



Analogously to the signature for streams, there is a forgetful functor from models for triangular matrices to coalgebras of a specific higher-order
endofunctor:

\begin{rem}[Coalgebras for $\Tri$]
  Let $E : \Set$ be a type. Define the functor
  \begin{align*}  F: [\Set,\Setoid] \to [\Set,\Setoid]  \enspace ,\enspace
                      F(G)(A) := \eq(A) \times G(E \times A) \enspace .
  \end{align*}
  There is a forgetful functor from models for infinite triangular matrices to coalgebras of $F$ which, intuitively, forgets the comonadic cobind operation and the $\cut$ operation.
  Indeed, given a model $(T,\tail^T)$, the comonad $T$ is, in particular, a functor $T:\Set\to\Setoid$ which constitutes the carrier of 
  a coalgebra of $F$. The coalgebra structure map on $T$, being a map $T \to \eq \times T(E\times \_ )$ into a product, 
  is assembled from the counit of $T$ (to give the first component) 
  and the comodule morphism $\tail^T : T \to T(E\times \_)$ (to give the second component).
  Note that both the counit and $\tail^T$ are natural transformations.
\end{rem}


   

\begin{theorem}\label{thm:final_sem_tri} 
   The pair $(\Tri, \tail)$ consisting of the relative comonad with cut $\Tri$ of Example \ref{def:cut_for_tri} together with 
    the morphism of comodules $\tail$ of Example \ref{ex:tail_comodule},
   constitutes the terminal model of triangular matrices.
\end{theorem}

\begin{proof}
   For a given model $(T,\tail^T)$, the (terminal) morphism $\bigcirc = \bigcirc_T:T\to\Tri$ is defined via the corecursive equations
% 
   \begin{align}  \comp{\bigcirc}{\head} &:= \counit^T \quad \text{ and } \label{eq:terminal_top}\\
                   \comp{\bigcirc}{\tail} &:= \comp{\tail^T}{\bigcirc} \enspace . \label{eq:terminal_rest}
    \end{align}

  \noindent
      Using the introduction axiom for bisimilarity we show that the map $\bigcirc$ commutes with $\cobind$ and $\cut$ operations of the source and 
   target models. We omit these calculations, which can be consulted in the \coq source files.
   
   Note that there is actually no choice in this definition: Equation \eqref{eq:terminal_top} is forced upon us since we want $\bigcirc$ to constitute 
   a morphism of comonads---the equation directly corresponds to one of the axioms.
   Equation \eqref{eq:terminal_rest} is forced upon us by the diagram of Equation \eqref{eq:tri_model}, which a morphism of models has to make commute.
   
   The same argument is used to show, again by use of the introduction rule for bisimilarity, that any two morphisms of models $\tau,\rho : (T,\tail^T) \to (\Tri,\tail)$
   are equal in the sense of being pointwise bisimilar, thus concluding the proof.   
\end{proof}

% This universal property characterizes not only the codata type $\Tri$, but also
% the bisimilarity relation on it as well as the cosubstitution operation.


\section{Formalization in \coq}\label{sec:formal}

All our definitions and theorems are mechanized in the proof assistant \coq \parencite{coq84pl4}.
In the formalization we add the rules of Figure \ref{stream_rules} and Figure \ref{tri_rules} as axioms to the \coq system, via the \lstinline!Axiom! vernacular. In order to ensure consistency, we 
\begin{enumerate}
 \item encapsulate the axioms in \coq \emph{module} types (separately for $\stream$ and for $\Tri$) and
 \item instantiate each module type by defining streams and triangular matrices as coinductive types using the \lstinline!CoInductive! vernacular,
  as shown in Figure \ref{tri_coinductive} for the example of $\Tri$.
\end{enumerate}
This shows that the axioms we add to \coq are weaker than the general mechanism of defining coinductive types in \coq via the \lstinline!CoInductive! vernacular.

\begin{figure}
%  \begin{mdframed}
  \begin{lstlisting}
CoInductive Tri A : Type :=
    constr : A -> Tri (E x A) -> Tri A.
CoInductive bisim : forall {A}, Tri A -> Tri A -> Prop :=
    bisim_constr : forall {A} {t t' : Tri A}, 
          top t = top t' /\ bisim (rest t) (rest t') -> 
          bisim t t'.
\end{lstlisting}
% Here, the code \lstinline!E x A! denotes the cartesian product of the types \lstinline!E! and \lstinline!A!.
%  \end{mdframed}
 \caption{Definition of $\Tri$ and bisimilarity using \coq's \lstinline!CoInductive! vernacular} \label{tri_coinductive}
\end{figure}


Apart from the implementation of our codata types via axioms (which are encapsulated in modules), the mechanization does \emph{not} rely on any additional axioms.
The \coq source files and HTML documentation are available from the project web site \parencite{trimat_coq}.
The correspondences between formalized statements and the statements in this article are given in Table \ref{sec:table_formal_informal}.



\begin{table}[hbt]
 \begin{mdframed}
  \input{formal_table}
 \end{mdframed}
 \caption{Correspondence of informal and formal definitions} \label{sec:table_formal_informal}
\end{table}


\section{Conclusion and future work}

We have given a categorical semantics for some homogeneous (streams and trees) and heterogeneous (infinite triangular matrices) codata types,
using the notion of relative comonad and comodule over such comonads.

It remains to investigate more general forms of heterogeneous trees, in particular, more general forms of heterogeneity than the one we have
considered here, given by precomposition with a product.
This necessitates a semantic analysis of the conditions that a functor (on the category of types) responsible for heterogeneity needs to satisfy in order to allow the lifting of a (co)substitution rule.

 \textit{Acknowledgments:}
 We are grateful to André Hirschowitz, Ralph Matthes and Paige North for many helpful discussions.
 We thank the referees for their suggestions and comments, and the editors for their efforts organizing these proceedings.
 
\bibliographystyle{plain}
\bibliography{literature}


\end{document}



















